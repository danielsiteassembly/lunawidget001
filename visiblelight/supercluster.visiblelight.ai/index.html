<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visible Light AI Supercluster</title>
    <link rel="stylesheet" type="text/css" href="https://supercluster.visiblelight.ai/styles.css" />
</head>
<body>
    <div
        id="vlSuperclusterRoot"
        class="vl-supercluster-root vl-supercluster"
        data-login-path="/supercluster-ai-constellation-login/"
    >


        <!-- Visible Light Supercluster Overlay -->
        <div class="vl-supercluster-overlay">
            <!-- Top Left: Logo and Client Info -->
            <div class="vl-header">
                <div class="vl-logo">
                    <img src="https://visiblelight.ai/wp-content/uploads/2025/10/visible-light-icon-logo.svg" alt="Visible Light Icon Logo" />
                </div>
                <div class="vl-client-greeting">
                    <h2>Hello, <span id="clientName">Client</span><span class="dropdown-arrow" id="clientDropdownArrow" style="cursor: pointer; display: inline-block;"><img src="https://visiblelight.ai/wp-content/uploads/2025/08/downarrow.svg" alt="dropdown arrow" style="pointer-events: auto;"></span></h2>
                </div>
            </div>

            <!-- Main Navigation Menu -->
            <nav class="vl-main-menu">
                <ul>
                    <li class="active">
                        <a href="#" data-section="supercluster">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/supercluster-loader.svg" alt="Supercluster Icon" /></span>
                            <span class="label">Supercluster</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="web-infra">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/web-and-infra-icon.svg" alt="Web & Infra Icon" /></span>
                            <span class="label">Web & Infra</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="content">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/content-manegement-and-structure-icon.svg" alt="content icon" /></span>
                            <span class="label">Content</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="search-intel">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/supercluster-search-icon-1.svg" alt="search intel icon" /></span>
                            <span class="label">Search Intel</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="reporting">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/supercluster-reporting-icon.svg" alt="reporting icon" /></span>
                            <span class="label">Reporting</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="marketing-ads">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/web-infra-icon-2.svg" alt="marketing and campaigns icon" /></span>
                            <span class="label">Marketing & Ads</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="ecommerce">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/e-commerce-icon.svg" alt="e-commerce and conversions icon" /></span>
                            <span class="label">Sales & Conversions</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="security-compliance">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/security-icon.svg" alt="security and compliance icon" /></span>
                            <span class="label">Security</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="cloudops">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/cloudops-icon.svg" alt="cloudops icon" /></span>
                            <span class="label">CloudOps</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="user-identity">
                            <span class="icon"><img width="49" height="46" decoding="async" src="https://visiblelight.ai/wp-content/uploads/2025/07/seamless-collaboration-icon.svg" alt="user identity icon" class="wp-image-541" style="aspect-ratio:1.0606060606060606;object-fit:cover;width:35px;height:auto"></span>
                            <span class="label">Users & Identity</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="competitive">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/competitive-icon.svg" alt="competitive icon" /></span>
                            <span class="label">Competitive</span>
                        </a>
                    </li>
                </ul>
            </nav>

            <!-- Bottom Left: License Key, Connection Status and Luna Chat -->
            <div class="vl-bottom-left">
                <div class="vl-license-key">
                    <div class="license-label">License Key</div>
                    <div class="license-container" id="licenseKeyContainer">
                        <span class="license-value" id="licenseKeyDisplay">Loading...</span>
                        <button class="copy-license-btn" id="copyLicenseBtn" title="Copy full license key">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="vl-connection-status" style="display: none;">
                    <div class="status-indicator">
                        <span class="status-icon" id="connectionIcon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/checkmark.svg" alt="check mark" /></span>
                    </div>
                    <div class="status-text">
                        <p><span class="status-label">Hub Status: </span>
                        <span class="status-value" id="connectionStatus">Active</span></p>
                    </div>
                </div>
                <!-- Luna Chat Widget will be injected here if plugin is installed and licensed -->
                <div class="vl-luna-chat" id="vlLunaChatContainer"></div>
            </div>

            <!-- Bottom Right: Controls -->
            <div class="vl-controls">
                <button class="control-btn" id="controlLeft" title="Move Left">
                    <span class="icon">←</span>
                </button>
                <button class="control-btn" id="controlRight" title="Move Right">
                    <span class="icon">→</span>
                </button>
                <button class="control-btn" id="controlZoomIn" title="Zoom In">
                    <span class="icon">+</span>
                </button>
                <button class="control-btn" id="controlZoomOut" title="Zoom Out">
                    <span class="icon">−</span>
                </button>
            </div>

            <!-- Right Sidebar: Your Supercluster + Recent Activity -->
            <aside class="vl-right-sidebar">
                <div class="vl-widget vl-widget-supercluster" id="yourSuperclusterWidget">
                    <div class="vl-widget-header">
                        <h3>Omniscient</h3>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <span class="vl-status-icon-wrap" title="VL Hub Status">
                            <img id="superclusterStatusIcon" src="https://visiblelight.ai/wp-content/uploads/2025/10/checkmark.svg" alt="Connected" />
                        </span>
                            <button class="vl-widget-toggle" data-widget="yourSuperclusterWidget" aria-label="Hide widget">
                                <img src="https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-hide-icon.svg" alt="Hide" class="vl-toggle-icon" />
                            </button>
                        </div>
                    </div>
                    <div class="vl-widget-body">
                        <p id="superclusterSummary">Loading your Supercluster…</p>
                    </div>
                </div>

                <div class="vl-widget vl-widget-activity" id="recentActivityWidget">
                    <div class="vl-widget-header">
                        <h3>Stream Activity</h3>
                        <button class="vl-widget-toggle" data-widget="recentActivityWidget" aria-label="Hide widget">
                            <img src="https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-hide-icon.svg" alt="Hide" class="vl-toggle-icon" />
                        </button>
                    </div>
                    <div class="vl-widget-body">
                        <ul id="recentActivityList" class="vl-activity-list">
                            <li class="vl-activity-empty">No recent activity.</li>
                        </ul>
                    </div>
                </div>
            </aside>

            <!-- Page Content Container (for category/stream pages) -->
            <div class="vl-page-content" id="vlPageContent" style="display: none;">
                <!-- Category/Stream content will be inserted here -->
            </div>
        </div>

        <!-- Client Dropdown Lightbox -->
        <div class="client-dropdown-lightbox" id="clientDropdownLightbox" style="display: none; position: fixed; z-index: 10000; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
            <div class="client-dropdown-content" id="clientDropdownContent" style="pointer-events: auto; position: absolute; background: #fff; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 8px 0; min-width: 150px;">
                <div class="client-dropdown-item" id="accountSettings" style="cursor: pointer; padding: 10px 15px;">
                    <span class="dropdown-text">Account Settings</span>
                </div>
                <div class="client-dropdown-item" id="logoutOption" style="cursor: pointer; padding: 10px 15px;">
                    <span class="dropdown-text">Log Out</span>
                </div>
            </div>
        </div>

        <!-- Logout Confirmation Modal -->
        <div class="logout-modal" id="logoutModal" style="display: none; position: fixed; z-index: 10001; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); pointer-events: auto;">
            <div class="logout-modal-content" style="pointer-events: auto;">
                <h3>Log Out</h3>
                <p>Are you sure you want to log out of Visible Light?</p>
                <div class="logout-modal-buttons">
                    <button class="logout-cancel" id="logoutCancel">No, stay logged in</button>
                    <button class="logout-confirm" id="logoutConfirm">Yes, log out now</button>
                </div>
            </div>
        </div>

        <!-- Tutorial Overlay -->
        <div class="tutorial-overlay" id="tutorialOverlay" style="display: none;">
            <div class="tutorial-backdrop" id="tutorialBackdrop"></div>
            <div class="tutorial-highlight" id="tutorialHighlight"></div>
            <div class="tutorial-content" id="tutorialContent">
                <button class="tutorial-close" id="tutorialClose" title="Close Tutorial">×</button>
                <div class="tutorial-step-content" id="tutorialStepContent">
                    <!-- Step content will be inserted here -->
                </div>
                <div class="tutorial-options" id="tutorialOptions" style="display: none;">
                    <label>
                        <input type="checkbox" id="tutorialNeverShow">
                        <span id="tutorialNeverShowLabel">Never show this tutorial again</span>
                    </label>
                </div>
                <div class="tutorial-navigation">
                    <button class="tutorial-btn tutorial-prev" id="tutorialPrev" style="display: none;">Previous</button>
                    <div class="tutorial-progress" id="tutorialProgress"></div>
                    <button class="tutorial-btn tutorial-next" id="tutorialNext">Next</button>
                </div>
            </div>
        </div>

    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
                "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

        // CRITICAL SECURITY: Verify authentication before allowing dashboard access
        const LOGIN_PAGE_URL = 'https://visiblelight.ai/auth/';
        
        // Check if we're on the Omniscient App Observatory page
        const currentParams = new URLSearchParams(window.location.search);
        const currentLicense = currentParams.get('license') || '';
        const isOmniscientPage = currentLicense.includes('/omniscient-app-observatory/');
        const isLunaComposePage = currentLicense.includes('/luna/compose/');
        const isLunaReportPage = currentLicense.includes('/luna/report/');
        const isLunaAutomatePage = currentLicense.includes('/luna/automate/');
        
        // Check if we're on a shared document page (invite_from)
        const currentPath = window.location.pathname;
        const isSharedComposePage = currentPath.includes('/invite_from/luna/compose/');
        let sharedDocumentId = null;
        if (isSharedComposePage) {
            const match = currentPath.match(/\/invite_from\/luna\/compose\/([^\/]+)/);
            if (match && match[1]) {
                sharedDocumentId = match[1];
            }
        }
        
        // Only load the loading animation script on the main Supercluster dashboard page
        // NOT on internal pages like /luna/compose/, /luna/report/, /luna/automate/, or /omniscient-app-observatory/
        const isMainDashboardPage = !isOmniscientPage && !isLunaComposePage && !isLunaReportPage && !isLunaAutomatePage;
        
        if (isMainDashboardPage) {
            const script = document.createElement('script');
            script.src = 'https://supercluster.visiblelight.ai/assets/js/supercluster-load-animation.js';
            script.async = true;
            document.head.appendChild(script);
        }
        
        // Render Omniscient App Observatory page
        async function renderOmniscientAppObservatory() {
            console.log('[Omniscient App Observatory] Rendering page...');
            
            // CRITICAL: Neutralize the Supercluster visualization canvas immediately
            const rootContainer = document.getElementById('vlSuperclusterRoot');
            if (rootContainer) {
                rootContainer.style.setProperty('display', 'block', 'important');
                rootContainer.style.setProperty('visibility', 'visible', 'important');
                rootContainer.style.setProperty('opacity', '1', 'important');
                rootContainer.style.setProperty('pointer-events', 'auto', 'important');
            }
            
            // Hide any canvas elements
            const canvas = document.querySelector('canvas');
            if (canvas) {
                canvas.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; pointer-events: none !important;';
            }
            
            // Ensure body background is transparent, not black
            document.body.style.cssText = 'background: transparent !important; background-color: transparent !important;';
            
            // Ensure overlays and menus remain visible
            const overlay = document.querySelector('.vl-supercluster-overlay');
            const header = document.querySelector('.vl-header');
            const mainMenu = document.querySelector('.vl-main-menu');
            const rightSidebar = document.querySelector('.vl-right-sidebar');
            
            if (overlay) {
                overlay.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (header) {
                header.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (mainMenu) {
                mainMenu.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (rightSidebar) {
                rightSidebar.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            
            // Show the page content container
            const pageContent = document.getElementById('vlPageContent');
            if (!pageContent) {
                console.error('[Omniscient App Observatory] Page content element not found!');
                return;
            }
            
            // Get license key from URL
            const urlParams = new URLSearchParams(window.location.search);
            const urlLicense = urlParams.get('license') || '';
            let licenseKey = '';
            if (urlLicense) {
                const licenseMatch = urlLicense.match(/^([^/]+)/);
                if (licenseMatch) {
                    licenseKey = licenseMatch[1];
                } else {
                    licenseKey = urlLicense;
                }
            }
            
            if (!licenseKey) {
                pageContent.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>License key not found.</p></div>';
                return;
            }
            
            try {
                console.log('[Omniscient App Observatory] Fetching sites for license:', licenseKey);
                
                // Fetch all sites for this client
                const response = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/client-sites?license=${encodeURIComponent(licenseKey)}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                
                console.log('[Omniscient App Observatory] Response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('[Omniscient App Observatory] API error:', response.status, errorText);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('[Omniscient App Observatory] Response data:', data);
                
                if (!data.ok) {
                    throw new Error(data.error || 'Invalid response from server');
                }
                
                const sites = data.sites || [];
                const totalSites = data.total || 0;
                
                console.log('[Omniscient App Observatory] Sites found:', totalSites, sites);
                
                // Build HTML with explicit background
                let html = '<div class="omniscient-observatory" style="min-height: 100vh; background: #000000 !important; color: #fff4e9; padding: 40px 20px; max-width: 1400px; margin: 0 auto; position: relative; z-index: 1000;">';
                
                // Header with total count
                html += '<div style="margin-bottom: 30px;">';
                html += '<h1 class="TypeGradient" style="margin-bottom: 10px; font-size: 2rem;">Omniscient App Observatory</h1>';
                html += '<p style="color: #9A9793; font-size: 1rem; margin: 0 0 20px 0;">Total Connected Sites/Apps: <strong style="color: #fff4e9;">' + totalSites + '</strong></p>';
                
                // Search and View Toggle
                html += '<div style="display: flex; align-items: center; gap: 20px; margin-bottom: 30px; flex-wrap: wrap;">';
                html += '<div style="flex: 1; min-width: 300px;">';
                html += '<input type="text" id="observatory-search" placeholder="Search sites/apps..." style="width: 100%; padding: 10px 16px; background: #2E2C2A50; border: 1px solid #5A575335; border-radius: 6px; color: #fff4e9; font-size: 0.875rem; outline: none;" />';
                html += '</div>';
                html += '<div style="display: flex; align-items: center; gap: 10px;">';
                html += '<span style="color: #9A9793; font-size: 0.875rem;">View:</span>';
                html += '<button id="view-list-btn" class="view-toggle-btn active" data-view="list" style="padding: 8px 16px; background: #2E2C2A; border: 1px solid #5A575335; color: #fff4e9; border-radius: 6px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease;">List</button>';
                html += '<button id="view-block-btn" class="view-toggle-btn" data-view="block" style="padding: 8px 16px; background: #2E2C2A50; border: 1px solid #5A575335; color: #9A9793; border-radius: 6px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease;">Block</button>';
                html += '</div>';
                html += '</div>';
                
                // Sites Container
                html += '<div id="observatory-sites-container" class="observatory-list-view" style="display: grid; gap: 20px;">';
                
                if (sites.length === 0) {
                    html += '<div style="text-align: center; padding: 60px 20px; color: #9A9793;"><p>No sites/apps found. Assign sites to this client in WP Admin > VL Clients > VL Hub Profile > Client Syncing.</p></div>';
                } else {
                    sites.forEach((site, index) => {
                        const siteId = 'site-' + index;
                        html += '<div class="observatory-site-item" data-site-url="' + (site.url || '').toLowerCase() + '" data-site-title="' + (site.title || '').toLowerCase() + '" data-site-domain="' + (site.domain || '').toLowerCase() + '" style="background: #000000; border: 1px solid #2E2C2A; border-radius: 8px; padding: 20px; transition: all 0.2s ease; cursor: pointer;" onmouseover="this.style.borderColor=\'#5A5753\';" onmouseout="this.style.borderColor=\'#2E2C2A\';" onclick="window.open(\'' + (site.url || '#') + '\', \'_blank\');">';
                        
                        // Block view layout
                        html += '<div class="observatory-site-block" style="display: grid; grid-template-columns: 120px 1fr auto; gap: 20px; align-items: start;">';
                        
                        // OG Image
                        html += '<div style="width: 120px; height: 120px; background: #2E2C2A; border-radius: 6px; overflow: hidden; flex-shrink: 0;">';
                        if (site.og_image) {
                            html += '<img src="' + site.og_image + '" alt="' + (site.title || site.domain || 'Site') + '" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.style.display=\'none\'; this.parentElement.innerHTML=\'<div style=\\\'width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:#9A9793;font-size:0.75rem;\\\'>No Image</div>\';" />';
                        } else {
                            html += '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: #9A9793; font-size: 0.75rem;">No Image</div>';
                        }
                        html += '</div>';
                        
                        // Site Info
                        html += '<div style="flex: 1;">';
                        html += '<h3 style="color: #fff4e9; margin: 0 0 8px 0; font-size: 1.2rem; font-weight: 400;">' + (site.title || site.domain || site.url || 'Untitled Site') + '</h3>';
                        html += '<p style="color: #9A9793; margin: 0 0 12px 0; font-size: 0.875rem; word-break: break-all;">' + (site.url || '') + '</p>';
                        
                        // Status badges
                        html += '<div style="display: flex; gap: 10px; flex-wrap: wrap;">';
                        
                        // Ping Status
                        html += '<span style="padding: 4px 12px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; background: ' + (site.ping_color || '#9A9793') + '; color: #000;">' + (site.ping_label || 'Unknown') + '</span>';
                        
                        // SSL/TLS Status
                        let sslLabel = 'Unknown';
                        let sslColor = '#9A9793';
                        if (site.ssl_status === 'valid') {
                            sslLabel = 'SSL Valid';
                            sslColor = '#00a32a';
                        } else if (site.ssl_status === 'expiring_soon') {
                            sslLabel = 'SSL Expiring Soon';
                            sslColor = '#dba617';
                        } else if (site.ssl_status === 'expired') {
                            sslLabel = 'SSL Expired';
                            sslColor = '#d63638';
                        } else if (site.ssl_status === 'not_https') {
                            sslLabel = 'Not HTTPS';
                            sslColor = '#9A9793';
                        }
                        html += '<span style="padding: 4px 12px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; background: ' + sslColor + '; color: #000;">' + sslLabel + '</span>';
                        
                        html += '</div>';
                        html += '</div>';
                        
                        html += '</div>';
                        
                        // List view layout (hidden by default)
                        html += '<div class="observatory-site-list" style="display: none; grid-template-columns: 80px 1fr auto auto; gap: 16px; align-items: center;">';
                        html += '<div style="width: 80px; height: 80px; background: #2E2C2A; border-radius: 6px; overflow: hidden; flex-shrink: 0;">';
                        if (site.og_image) {
                            html += '<img src="' + site.og_image + '" alt="' + (site.title || site.domain || 'Site') + '" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.style.display=\'none\';" />';
                        }
                        html += '</div>';
                        html += '<div style="flex: 1; min-width: 0;">';
                        html += '<h3 style="color: #fff4e9; margin: 0 0 4px 0; font-size: 1rem; font-weight: 400; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + (site.title || site.domain || site.url || 'Untitled Site') + '</h3>';
                        html += '<p style="color: #9A9793; margin: 0; font-size: 0.875rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + (site.url || '') + '</p>';
                        html += '</div>';
                        html += '<div style="display: flex; gap: 8px;">';
                        html += '<span style="padding: 4px 12px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; background: ' + (site.ping_color || '#9A9793') + '; color: #000;">' + (site.ping_label || 'Unknown') + '</span>';
                        html += '<span style="padding: 4px 12px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; background: ' + sslColor + '; color: #000;">' + sslLabel + '</span>';
                        html += '</div>';
                        html += '</div>';
                        
                        html += '</div>';
                    });
                }
                
                html += '</div>';
                html += '</div>';
                
                // Add CSS
                html += '<style>';
                html += '.observatory-list-view .observatory-site-item > .observatory-site-list { display: grid !important; }';
                html += '.observatory-list-view .observatory-site-item > .observatory-site-block { display: none !important; }';
                html += '.observatory-block-view .observatory-site-item > .observatory-site-block { display: grid !important; }';
                html += '.observatory-block-view .observatory-site-item > .observatory-site-list { display: none !important; }';
                html += '.view-toggle-btn.active { background: #2E2C2A !important; color: #fff4e9 !important; }';
                html += '.view-toggle-btn:not(.active) { background: #2E2C2A50 !important; color: #9A9793 !important; }';
                html += '</style>';
                
                pageContent.innerHTML = html;
                
                // CRITICAL: Force page content to be visible with !important styles
                pageContent.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 1000 !important; background: #000000 !important; min-height: 100vh !important;';
                
                // Ensure body and html background doesn't cover content
                document.body.style.cssText = 'background: transparent !important; background-color: transparent !important;';
                if (document.documentElement) {
                    document.documentElement.style.cssText = 'background: transparent !important; background-color: transparent !important;';
                }
                
                // Keep the Supercluster container visible while suppressing any canvases
                const rootContainer = document.getElementById('vlSuperclusterRoot');
                if (rootContainer) {
                    rootContainer.style.setProperty('display', 'block', 'important');
                    rootContainer.style.setProperty('visibility', 'visible', 'important');
                    rootContainer.style.setProperty('opacity', '1', 'important');
                    rootContainer.style.setProperty('pointer-events', 'auto', 'important');
                }
                
                // Hide any canvas elements that might be covering content
                const canvasElements = document.querySelectorAll('canvas');
                canvasElements.forEach(canvas => {
                    canvas.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; pointer-events: none !important; z-index: -1 !important;';
                });
                
                // Force overlays to remain visible
                const overlay = document.querySelector('.vl-supercluster-overlay');
                const header = document.querySelector('.vl-header');
                const mainMenu = document.querySelector('.vl-main-menu');
                const rightSidebar = document.querySelector('.vl-right-sidebar');
                
                if (overlay) {
                    overlay.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                }
                if (header) {
                    header.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                }
                if (mainMenu) {
                    mainMenu.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                }
                if (rightSidebar) {
                    rightSidebar.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                }
                
                // Use MutationObserver to prevent content from being hidden
                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                            const target = mutation.target;
                            if (target === pageContent) {
                                const display = window.getComputedStyle(target).display;
                                if (display === 'none') {
                                    console.warn('[Omniscient] Page content was hidden, forcing it visible');
                                    target.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 10 !important;';
                                }
                            }
                        }
                    });
                });
                
                observer.observe(pageContent, {
                    attributes: true,
                    attributeFilter: ['style', 'class']
                });
                
                // Also set up periodic checks to ensure content stays visible
                const visibilityCheck = setInterval(() => {
                    const computedDisplay = window.getComputedStyle(pageContent).display;
                    if (pageContent.style.display === 'none' || computedDisplay === 'none') {
                        console.warn('[Omniscient] Page content hidden, restoring visibility');
                        pageContent.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 1000 !important; background: transparent !important;';
                    }
                    
                    // Ensure the Supercluster container remains visible for UI elements
                    if (rootContainer) {
                        const rootDisplay = window.getComputedStyle(rootContainer).display;
                        if (rootDisplay === 'none') {
                            rootContainer.style.setProperty('display', 'block', 'important');
                            rootContainer.style.setProperty('visibility', 'visible', 'important');
                            rootContainer.style.setProperty('opacity', '1', 'important');
                            rootContainer.style.setProperty('pointer-events', 'auto', 'important');
                        }
                    }
                    
                    // Ensure canvas stays hidden
                    const canvasElements = document.querySelectorAll('canvas');
                    canvasElements.forEach(canvas => {
                        const canvasDisplay = window.getComputedStyle(canvas).display;
                        if (canvasDisplay !== 'none') {
                            canvas.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; pointer-events: none !important; z-index: -1 !important;';
                        }
                    });
                    
                    // Ensure body/html backgrounds stay transparent
                    const bodyBg = window.getComputedStyle(document.body).backgroundColor;
                    if (bodyBg && bodyBg !== 'transparent' && bodyBg !== 'rgba(0, 0, 0, 0)') {
                        document.body.style.cssText = 'background: transparent !important; background-color: transparent !important;';
                    }
                }, 500);
                
                // Store interval ID for cleanup if needed
                window.omniscientVisibilityCheck = visibilityCheck;
                
                // Initialize search and view toggle
                const searchInput = document.getElementById('observatory-search');
                const viewListBtn = document.getElementById('view-list-btn');
                const viewBlockBtn = document.getElementById('view-block-btn');
                const sitesContainer = document.getElementById('observatory-sites-container');
                
                // Search functionality
                if (searchInput) {
                    searchInput.addEventListener('input', function(e) {
                        const searchTerm = e.target.value.toLowerCase().trim();
                        const siteItems = document.querySelectorAll('.observatory-site-item');
                        
                        siteItems.forEach(item => {
                            const url = item.getAttribute('data-site-url') || '';
                            const title = item.getAttribute('data-site-title') || '';
                            const domain = item.getAttribute('data-site-domain') || '';
                            
                            if (!searchTerm || url.includes(searchTerm) || title.includes(searchTerm) || domain.includes(searchTerm)) {
                                item.style.display = '';
                            } else {
                                item.style.display = 'none';
                            }
                        });
                    });
                }
                
                // View toggle functionality
                if (viewListBtn && viewBlockBtn && sitesContainer) {
                    viewListBtn.addEventListener('click', function() {
                        sitesContainer.className = 'observatory-list-view';
                        viewListBtn.classList.add('active');
                        viewBlockBtn.classList.remove('active');
                    });
                    
                    viewBlockBtn.addEventListener('click', function() {
                        sitesContainer.className = 'observatory-block-view';
                        viewBlockBtn.classList.add('active');
                        viewListBtn.classList.remove('active');
                    });
                }
                
            } catch (error) {
                console.error('[Omniscient App Observatory] Error rendering:', error);
                pageContent.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load Omniscient App Observatory: ' + error.message + '</p></div>';
            }
        }
        
        // Render shared Luna Composer page (public access without license key)
        // Define this function early so it can be called for shared documents
        async function renderSharedLunaComposer(shareId) {
            try {
                console.log('[Luna Composer] Rendering shared document:', shareId);
                
                // Fetch shared document from WordPress
                let docData = null;
                try {
                    const response = await fetch(`https://visiblelight.ai/wp-json/luna_widget/v1/composer/shared?share_id=${encodeURIComponent(shareId)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.document) {
                            docData = data.document;
                            console.log('[Luna Composer] Shared document loaded:', docData);
                        } else {
                            console.error('[Luna Composer] Document not found');
                            const pageContentEl = document.getElementById('vlPageContent');
                            if (pageContentEl) {
                                pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Document Not Found</h1><p>The shared document could not be found or has been removed.</p></div>';
                            }
                            return;
                        }
                    } else {
                        console.error('[Luna Composer] Failed to load shared document:', response.status);
                        const pageContentEl = document.getElementById('vlPageContent');
                        if (pageContentEl) {
                            pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load shared document.</p></div>';
                        }
                        return;
                    }
                } catch (e) {
                    console.error('[Luna Composer] Error loading shared document:', e);
                    const pageContentEl = document.getElementById('vlPageContent');
                    if (pageContentEl) {
                        pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load shared document.</p></div>';
                    }
                    return;
                }
                
                // Hide Supercluster elements
                const rootContainer = document.getElementById('vlSuperclusterRoot');
                const pageContent = document.getElementById('vlPageContent');
                if (rootContainer) {
                    rootContainer.style.display = 'none';
                }
                if (pageContent) {
                    pageContent.style.display = 'block';
                }
                
                // Remove three.js and other Supercluster elements
                const controls = document.querySelector('.vl-controls');
                if (controls) controls.remove();
                const labelsContainer = document.querySelector('.vl-supercluster-labels');
                if (labelsContainer) labelsContainer.remove();
                const canvas = document.querySelector('canvas');
                if (canvas) canvas.style.display = 'none';
                
                // Build shared document viewer (read-only)
                let html = '<style>@media (min-width: 991px) { .luna-composer-page { max-width: 55% !important; } }</style>';
                html += '<div class="luna-composer-page" style="min-height: 100vh; background: transparent; color: #fff4e9; padding: 40px 0; max-width: 1200px; margin: 0 auto; position: relative; z-index: 2;">';
                html += '<div class="luna-composer__editor" style="margin-bottom: 0; min-width: 100%;">';
                html += '<h1 class="TypeGradient" style="margin-bottom: 20px; font-size: 1.5rem; margin-top: 0;">Shared Document</h1>';
                html += '<div id="luna-composer-shared-editor" style="min-height: 400px; padding: 20px; background: #000; border: 1px solid #1f1d1a; border-radius: 8px; color: #fff4e9; font-size: 1rem; line-height: 1.6;">';
                html += docData.content || '<p>No content available.</p>';
                html += '</div>';
                html += '</div>';
                html += '</div>';

                const pageContentEl = document.getElementById('vlPageContent');
                if (pageContentEl) {
                    pageContentEl.innerHTML = html;
                    pageContentEl.style.display = 'block';
                }
            } catch (error) {
                console.error('[Luna Composer] Error rendering shared document:', error);
                const pageContentEl = document.getElementById('vlPageContent');
                if (pageContentEl) {
                    pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load shared document: ' + error.message + '</p></div>';
                }
            }
        }
        
        // Authentication check function
        async function verifyAuthenticationAndLicense() {
            try {
                // First, verify user is authenticated by checking VL Hub session
                // Include license in session check to allow cookie-less fallback
                const sessionUrl = new URL('https://visiblelight.ai/wp-json/vl-hub/v1/session');
                const currentParams = new URLSearchParams(window.location.search);
                const currentUrlLicenseParam = currentParams.get('license');
                
                // Extract just the license key (before first /) if URL contains path segments
                let extractedLicenseKey = '';
                if (currentUrlLicenseParam) {
                    // Check if license param contains path segments (e.g., "VL-XXX/category/data-stream/...")
                    const licenseMatch = currentUrlLicenseParam.match(/^([^/]+)/);
                    if (licenseMatch) {
                        extractedLicenseKey = licenseMatch[1];
                    } else {
                        extractedLicenseKey = currentUrlLicenseParam;
                    }
                }
                
                // Send only the license key (not the full path) to the session endpoint
                if (extractedLicenseKey) {
                    sessionUrl.searchParams.set('license', extractedLicenseKey);
                }

                const sessionResponse = await fetch(sessionUrl.toString(), {
                    method: 'GET',
                    credentials: 'include', // Send cookies
                    cache: 'no-store',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });

                if (!sessionResponse.ok) {
                    console.log('Session check failed - redirecting to login');
                    window.location.href = LOGIN_PAGE_URL;
                    return null;
                }

                const sessionData = await sessionResponse.json();
                
                if (!sessionData || sessionData.authenticated !== true) {
                    console.log('User not authenticated - redirecting to login');
                    window.location.href = LOGIN_PAGE_URL;
                    return null;
                }
                
                // Get user's actual license key from session
                const userLicenseKey = sessionData.license_key || sessionData.wp_activation_key || '';
                
                console.log('Extracted license key from URL:', extractedLicenseKey);
                console.log('User license key from session:', userLicenseKey);

                // SECURITY: Verify URL license key matches authenticated user's license key
                if (!userLicenseKey) {
                    console.log('No license key found for authenticated user - redirecting to login');
                    window.location.href = LOGIN_PAGE_URL;
                    return null;
                }

                // If URL has a license key, it MUST match the user's actual license key
                // Compare only the extracted license key (not the full path)
                if (extractedLicenseKey && extractedLicenseKey.toUpperCase() !== userLicenseKey.toUpperCase()) {
                    console.error('SECURITY VIOLATION: URL license key does not match authenticated user license key');
                    console.error('URL License:', extractedLicenseKey);
                    console.error('User License:', userLicenseKey);
                    alert('Access denied: License key mismatch. Redirecting to login...');
                    window.location.href = LOGIN_PAGE_URL;
                    return null;
                }

                // Use the authenticated user's license key (not from URL)
                console.log('Authentication verified. Using license key:', userLicenseKey);
                
                // SECURITY: Update URL license parameter only if it doesn't match user's license key
                // But preserve the full path if it exists (for stream data pages)
                const currentUrl = new URL(window.location.href);
                const currentLicenseParam = currentUrl.searchParams.get('license');
                
                // If license param doesn't start with user's license key, update it
                // But preserve path segments if they exist
                if (currentLicenseParam && !currentLicenseParam.startsWith(userLicenseKey)) {
                    // If there's a path after the license key, preserve it
                    const pathMatch = currentLicenseParam.match(/^[^/]+(\/.+)$/);
                    if (pathMatch) {
                        // This shouldn't happen if we extracted correctly, but handle it
                        currentUrl.searchParams.set('license', userLicenseKey + pathMatch[1]);
                    } else {
                    currentUrl.searchParams.set('license', userLicenseKey);
                    }
                    // Update URL without page reload (for security - ensures URL matches user)
                    window.history.replaceState({}, '', currentUrl.toString());
                }
                
                return userLicenseKey;

            } catch (error) {
                console.error('Authentication verification failed:', error);
                window.location.href = LOGIN_PAGE_URL;
                return null;
            }
        }

        // For shared documents, skip authentication and render directly
        if (isSharedComposePage && sharedDocumentId) {
            console.log('[Supercluster] Shared document detected, bypassing authentication');
            // Render shared document without authentication
            async function renderSharedDocumentDirectly() {
                try {
                    // Hide Supercluster elements
                    const rootContainer = document.getElementById('vlSuperclusterRoot');
                    const pageContent = document.getElementById('vlPageContent');
                    if (rootContainer) {
                        rootContainer.style.display = 'none';
                    }
                    if (pageContent) {
                        pageContent.style.display = 'block';
                    }
                    
                    // Remove three.js and other Supercluster elements
                    const controls = document.querySelector('.vl-controls');
                    if (controls) controls.remove();
                    const labelsContainer = document.querySelector('.vl-supercluster-labels');
                    if (labelsContainer) labelsContainer.remove();
                    const canvas = document.querySelector('canvas');
                    if (canvas) canvas.style.display = 'none';
                    
                    // Fetch and render shared document
                    await renderSharedLunaComposer(sharedDocumentId);
                } catch (error) {
                    console.error('[Supercluster] Error rendering shared document:', error);
                    const pageContentEl = document.getElementById('vlPageContent');
                    if (pageContentEl) {
                        pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load shared document: ' + error.message + '</p></div>';
                    }
                }
            }
            
            // Render immediately without authentication
            renderSharedDocumentDirectly();
        } else {
            // Verify authentication BEFORE doing anything else (for non-shared pages)
            var licenseKey = await verifyAuthenticationAndLicense();
        
        if (!licenseKey) {
            // Authentication failed - page will redirect, but prevent further execution
            // Show loading message while redirect happens
            document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;color:#fff4e9;font-family:Inter,sans-serif">Verifying authentication...</div>';
            // Stop execution - user is being redirected
            throw new Error('Authentication required');
        }

        // Data fetching from VL Hub
        let constellationData = null;
        let dataFetchError = null;

        // Inactivity timeout - 1 hour
        let inactivityTimeout = null;
        const INACTIVITY_TIMEOUT_MS = 60 * 60 * 1000; // 1 hour in milliseconds

        // Track user activity and reset timeout
        function resetInactivityTimer() {
            if (inactivityTimeout) {
                clearTimeout(inactivityTimeout);
            }
            
            inactivityTimeout = setTimeout(() => {
                console.log('Inactivity timeout reached - logging out');
                // Clear any stored data
                try {
                    localStorage.removeItem('vl-cms-data');
                    sessionStorage.clear();
                } catch (e) {
                    console.warn('Error clearing storage:', e);
                }
                
                // Redirect to login page (LOGIN_PAGE_URL is defined at top of script)
                window.location.href = LOGIN_PAGE_URL;
            }, INACTIVITY_TIMEOUT_MS);
        }

        // Listen for user activity events
        const activityEvents = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
        activityEvents.forEach(event => {
            document.addEventListener(event, resetInactivityTimer, { passive: true });
        });

        // Initialize inactivity timer on page load
        resetInactivityTimer();

        async function fetchConstellationData() {
            try {
                const endpoint = 'https://visiblelight.ai/wp-json/vl-hub/v1/constellation';
                const url = licenseKey ? `${endpoint}?license=${encodeURIComponent(licenseKey)}` : endpoint;
                
                console.log('Fetching constellation data from:', url);
                
                // Update debug info
                updateDebugInfo(`Fetching: ${url}`);
                
                const response = await fetch(url, {
                    method: 'GET',
                    credentials: 'include', // Send cookies for CORS
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });

                console.log('Response status:', response.status);
                console.log('Response headers:', [...response.headers.entries()]);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Error response body:', errorText);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}\nResponse: ${errorText}`);
                }

                const data = await response.json();
                console.log('Constellation data received:', data);
                updateDebugInfo(`Success: ${data.total_clients || 0} clients found`);
                return data;
            } catch (error) {
                console.error('Failed to fetch constellation data:', error);
                dataFetchError = error.message;
                updateDebugInfo(`Error: ${error.message}`);
                return null;
            }
        }

        function updateDebugInfo(message) {
            const debugEl = document.getElementById('debugInfo');
            if (debugEl) {
                const timestamp = new Date().toLocaleTimeString();
                debugEl.innerHTML = `[${timestamp}] ${message}`;
            }
        }

        // Function to update galaxy data with real VL Hub data
        function updateGalaxyDataWithRealData(clientData) {
            console.log('Updating galaxy data with real data:', clientData);
            
            // Check if galaxyData is defined
            if (typeof galaxyData === 'undefined' || !galaxyData || !Array.isArray(galaxyData)) {
                console.warn('[Supercluster] galaxyData not yet initialized, skipping update');
                return;
            }
            
            // Update galaxy data with real metrics
            galaxyData.forEach(galaxy => {
                const matchingCategory = clientData.categories?.find(cat => 
                    galaxy.datasetSlugs.some(slug => 
                        cat.name.toLowerCase().includes(slug.toLowerCase()) ||
                        cat.name.toLowerCase().includes('infrastructure') && slug === 'infrastructure' ||
                        cat.name.toLowerCase().includes('content') && slug === 'content' ||
                        cat.name.toLowerCase().includes('security') && slug === 'security' ||
                        cat.name.toLowerCase().includes('plugins') && slug === 'plugins' ||
                        cat.name.toLowerCase().includes('users') && slug === 'users' ||
                        cat.name.toLowerCase().includes('ai') && slug === 'ai' ||
                        cat.name.toLowerCase().includes('sessions') && slug === 'sessions' ||
                        cat.name.toLowerCase().includes('integrations') && slug === 'integrations'
                    )
                );

                if (matchingCategory) {
                    galaxy.metrics = {
                        categoryName: matchingCategory.name,
                        clientName: clientData.client,
                        nodesCount: matchingCategory.nodes?.length || 0,
                        topNodes: matchingCategory.nodes?.slice(0, 4).map(node => ({
                            label: node.label,
                            detail: node.detail
                        })) || []
                    };
                    galaxy.description = `Real-time data from ${clientData.client}: ${matchingCategory.nodes?.length || 0} active signals`;
                }
            });
        }

        // Update verification panel with data
        function updateVerificationPanel(data, error = null) {
            const licenseEl = document.getElementById('verificationLicense');
            const endpointEl = document.getElementById('verificationEndpoint');
            const statusEl = document.getElementById('verificationStatus');
            const clientsEl = document.getElementById('verificationClients');
            const lastUpdateEl = document.getElementById('verificationLastUpdate');
            const dataEl = document.getElementById('verificationData');

            if (licenseEl) licenseEl.textContent = licenseKey || 'No license key';
            if (endpointEl) endpointEl.textContent = '/wp-json/vl-hub/v1/constellation';
            
            if (error) {
                if (statusEl) statusEl.textContent = `Error: ${error}`;
                if (statusEl) statusEl.style.color = '#f85149';
                if (clientsEl) clientsEl.textContent = 'Failed';
                if (lastUpdateEl) lastUpdateEl.textContent = new Date().toLocaleTimeString();
                if (dataEl) dataEl.textContent = `Error: ${error}`;
            } else if (data) {
                if (statusEl) statusEl.textContent = 'Connected';
                if (statusEl) statusEl.style.color = '#56d364';
                if (clientsEl) clientsEl.textContent = data.total_clients || 0;
                if (lastUpdateEl) lastUpdateEl.textContent = new Date().toLocaleTimeString();
                if (dataEl) dataEl.textContent = JSON.stringify(data, null, 2);
            } else {
                if (statusEl) statusEl.textContent = 'No data';
                if (statusEl) statusEl.style.color = '#f2cc60';
                if (clientsEl) clientsEl.textContent = '0';
                if (lastUpdateEl) lastUpdateEl.textContent = new Date().toLocaleTimeString();
                if (dataEl) dataEl.textContent = 'No data received';
            }
        }

        // Toggle verification panel
        function toggleVerificationPanel() {
            const content = document.getElementById('verificationContent');
            const button = document.getElementById('toggleVerification');
            if (content && button) {
                const isVisible = content.style.display !== 'none';
                content.style.display = isVisible ? 'none' : 'block';
                content.classList.toggle('show', !isVisible);
                button.textContent = isVisible ? 'Show Details' : 'Hide Details';
            }
        }

        // Manual sync function
        async function syncFromHub() {
            const syncBtn = document.getElementById('syncFromHub');
            if (syncBtn) {
                syncBtn.disabled = true;
                syncBtn.textContent = 'Syncing...';
            }

            updateDebugInfo('Manual sync initiated...');
            updateVerificationPanel(null, 'Syncing...');

            try {
                const data = await fetchConstellationData();
                constellationData = data;
                updateVerificationPanel(data, dataFetchError);
                
                if (data && data.clients && data.clients.length > 0) {
                    updateGalaxyDataWithRealData(data.clients[0]);
                    updateDebugInfo(`Sync complete: ${data.total_clients} clients loaded`);
                    // Refresh client name after constellation data is loaded
                    await updateClientName();
                } else {
                    updateDebugInfo('Sync complete: No client data found');
                }
            } catch (error) {
                updateDebugInfo(`Sync failed: ${error.message}`);
                updateVerificationPanel(null, error.message);
            } finally {
                if (syncBtn) {
                    syncBtn.disabled = false;
                    syncBtn.textContent = 'Sync From Hub';
                }
            }
        }

        // Add event listeners
        document.addEventListener('DOMContentLoaded', () => {
            const toggleBtn = document.getElementById('toggleVerification');
            const syncBtn = document.getElementById('syncFromHub');
            
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleVerificationPanel);
            }
            
            if (syncBtn) {
                syncBtn.addEventListener('click', syncFromHub);
            }

            // Initialize Visible Light overlay
            initializeVLOverlay();
            
            // Also refresh client name after a delay to ensure constellation data is loaded
            setTimeout(async () => {
                console.log('Delayed client name refresh...');
                await refreshClientName();
            }, 2000);
        });

        // Initialize Visible Light overlay functionality
        async function initializeVLOverlay() {
            // Update client name from license key
            await updateClientName();
            
            // Update license key display
            updateLicenseKeyDisplay();
            
            // Setup menu navigation
            setupMenuNavigation();
            
            // Setup connection status
            setupConnectionStatus();
            
            // Setup control buttons
            setupControlButtons();
            
            // Setup client dropdown - retry if needed
            setupClientDropdown();
            
            // Retry dropdown setup after a delay if elements weren't found
            setTimeout(() => {
                const arrow = document.getElementById('clientDropdownArrow');
                const lightbox = document.getElementById('clientDropdownLightbox');
                if (!arrow || !lightbox) {
                    console.log('Retrying dropdown setup...');
            setupClientDropdown();
                }
            }, 1000);
            
            // Setup tutorial event listeners
            setupTutorial();
            
            // Check if user is first-time and show tutorial
            checkAndShowTutorial();
        }

        // Update client name from license key
        async function updateClientName() {
            const clientNameEl = document.getElementById('clientName');
            if (clientNameEl) {
                console.log('Starting client name update process...');
                
                // First priority: Use tutorialUsername (same source as tutorial checkbox)
                // This ensures consistency - same username shown in greeting and tutorial
                if (tutorialUsername) {
                    console.log('Using tutorialUsername from tutorial-status endpoint:', tutorialUsername);
                    clientNameEl.textContent = tutorialUsername;
                    return;
                }
                
                // Second priority: Try to get user data from constellation data
                if (constellationData && constellationData.clients && constellationData.clients.length > 0) {
                    const clientData = constellationData.clients[0];
                    console.log('Checking constellation data for user info:', clientData);
                    
                    // Try to get client name from constellation client field first
                    console.log('clientData.client value:', clientData.client);
                    if (clientData.client && clientData.client !== 'Unassigned Client') {
                        const firstName = clientData.client.split(' ')[0];
                        console.log('Using first name from constellation client field:', firstName);
                        console.log('Setting clientNameEl.textContent to:', firstName);
                        clientNameEl.textContent = firstName;
                        return;
                    }
                    
                    // Check if there's user data in the constellation response
                    if (clientData.user_data && clientData.user_data.display_name) {
                        const firstName = clientData.user_data.display_name.split(' ')[0];
                        console.log('Using first name from constellation user_data:', firstName);
                        clientNameEl.textContent = firstName;
                        return;
                    }
                    
                    // Check if there's a user_id in the constellation data
                    if (clientData.user_id) {
                        try {
                            console.log('Trying to get user data by user_id:', clientData.user_id);
                            const response = await fetch(`/wp-json/wp/v2/users/${clientData.user_id}`, {
                                method: 'GET',
                                credentials: 'same-origin'
                            });
                            
                            if (response.ok) {
                                const userData = await response.json();
                                console.log('User data by user_id:', userData);
                                if (userData && userData.name) {
                                    const firstName = userData.name.split(' ')[0];
                                    console.log('Using first name from user_id lookup:', firstName);
                                    clientNameEl.textContent = firstName;
                                    return;
                                }
                            }
                        } catch (error) {
                            console.log('User_id lookup error:', error);
                        }
                    }
                }

                // Second priority: Try to get current user's display name using custom endpoint
                try {
                    console.log('Trying custom endpoint: /wp-json/myplugin/v1/current-user');
                    const response = await fetch('/wp-json/myplugin/v1/current-user', {
                        method: 'GET',
                        credentials: 'same-origin'
                    });
                    
                    console.log('Custom endpoint response status:', response.status);
                    if (response.ok) {
                        const userData = await response.json();
                        console.log('Custom endpoint user data:', userData);
                        if (userData && userData.display_name) {
                            // Extract first name from display_name
                            const firstName = userData.display_name.split(' ')[0];
                            console.log('Using first name from custom endpoint:', firstName);
                            clientNameEl.textContent = firstName;
                            return;
                        }
                    }
                } catch (error) {
                    console.log('Custom endpoint error:', error);
                }

                // Second priority: Try default WordPress users endpoint
                try {
                    console.log('Trying WordPress API: /wp-json/wp/v2/users/me');
                    const response = await fetch('/wp-json/wp/v2/users/me', {
                        method: 'GET',
                        credentials: 'same-origin'
                    });
                    
                    console.log('WordPress API response status:', response.status);
                    if (response.ok) {
                        const userData = await response.json();
                        console.log('WordPress API user data:', userData);
                        if (userData && userData.name) {
                            // Extract first name from name field
                            const firstName = userData.name.split(' ')[0];
                            console.log('Using first name from WordPress API:', firstName);
                            clientNameEl.textContent = firstName;
                            return;
                        }
                    } else {
                        const errorText = await response.text();
                        console.log('WordPress API error response:', errorText);
                    }
                } catch (error) {
                    console.log('WordPress API error:', error);
                }

                // Third priority: Try to get display name from Luna License Manager session
                if (licenseKey) {
                    console.log('Trying Luna License Manager session...');
                    const sessionData = await fetchUserDisplayName();
                    console.log('Luna License Manager session data:', sessionData);
                    if (sessionData && sessionData.user && sessionData.user.display_name) {
                        // Extract first word from display_name
                        const firstName = sessionData.user.display_name.split(' ')[0];
                        console.log('Using first name from Luna License Manager:', firstName);
                        clientNameEl.textContent = firstName;
                        return;
                    }
                    
                    // Try to get first name from WordPress user data as fallback
                    console.log('Trying WordPress user data fallback...');
                    const userData = await fetchUserData();
                    console.log('WordPress user data fallback:', userData);
                    if (userData && userData.first_name) {
                        console.log('Using first name from WordPress user data:', userData.first_name);
                        clientNameEl.textContent = userData.first_name;
                        return;
                    }
                    
                    // Final fallback - DON'T use license key, just use default
                    console.log('No name found, using default "Client"');
                    clientNameEl.textContent = 'Client';
                } else {
                    // No license key, use default
                    console.log('No license key, using default "Client"');
                    clientNameEl.textContent = 'Client';
                }
            }
        }

        // Refresh client name when constellation data is updated
        async function refreshClientName() {
            await updateClientName();
        }

        // Fetch user data from WordPress API
        async function fetchUserData() {
            try {
                const response = await fetch('https://visiblelight.ai/wp-json/wp/v2/users/me', {
                    credentials: 'include'
                });
                if (response.ok) {
                    const userData = await response.json();
                    console.log('User data from WordPress:', userData);
                    return userData;
                }
            } catch (error) {
                console.log('Could not fetch user data:', error);
            }
            return null;
        }

        // Fetch user display name from Luna License Manager API
        async function fetchUserDisplayName() {
            try {
                const response = await fetch('https://visiblelight.ai/wp-json/vl-hub/v1/session', {
                    credentials: 'include'
                });
                if (response.ok) {
                    const sessionData = await response.json();
                    console.log('Session data from Luna License Manager:', sessionData);
                    return sessionData;
                }
            } catch (error) {
                console.log('Could not fetch session data:', error);
            }
            return null;
        }

        // Get client name from license key or VL Hub data
        function getClientNameFromLicense(license) {
            console.log('Getting client name, constellationData:', constellationData);
            
            // Try to get client name from constellation data first
            if (constellationData && constellationData.clients && constellationData.clients.length > 0) {
                const clientData = constellationData.clients[0];
                console.log('Client data found:', clientData);
                if (clientData.client && clientData.client !== 'Unassigned Client') {
                    // Extract first name from client name
                    const firstName = clientData.client.split(' ')[0];
                    console.log('Using first name from VL Hub:', firstName);
                    return firstName;
                }
            }
            
            // For "Unassigned Client", try to get first name from user data or site URL
            if (constellationData && constellationData.clients && constellationData.clients.length > 0) {
                const clientData = constellationData.clients[0];
                
                // Try to get first name from user data if available
                if (clientData.user_data && clientData.user_data.first_name) {
                    console.log('Using first name from user data:', clientData.user_data.first_name);
                    return clientData.user_data.first_name;
                }
                
                // Fallback to site URL extraction
                if (clientData.site) {
                    try {
                        const url = new URL(clientData.site);
                        const domain = url.hostname.replace('www.', '');
                        const siteName = domain.split('.')[0];
                        if (siteName && siteName.length > 2) {
                            console.log('Using site name as fallback:', siteName);
                            return siteName.charAt(0).toUpperCase() + siteName.slice(1);
                        }
                    } catch (e) {
                        console.log('Could not parse site URL:', e);
                    }
                }
                
                // Try to get name from display_name if available
                if (clientData.user_data && clientData.user_data.display_name) {
                    const firstName = clientData.user_data.display_name.split(' ')[0];
                    console.log('Using first name from display_name:', firstName);
                    return firstName;
                }
                
                // Try to get name from the name field if available
                if (clientData.name) {
                    const firstName = clientData.name.split(' ')[0];
                    console.log('Using first name from name field:', firstName);
                    return firstName;
                }
            }
            
            // Fallback to license key parsing - REMOVED: Don't use license key as it's sensitive
            // Instead, just return 'Client' as the default
            console.log('Using default client name');
            return 'Client';
        }

        // Update license key display
        function updateLicenseKeyDisplay() {
            console.log('updateLicenseKeyDisplay called, licenseKey:', licenseKey);
            const licenseKeyEl = document.getElementById('licenseKeyDisplay');
            const copyBtn = document.getElementById('copyLicenseBtn');
            console.log('licenseKeyEl:', licenseKeyEl, 'copyBtn:', copyBtn);
            
            if (licenseKeyEl) {
                if (licenseKey) {
                    // Only show "VL-" plus first four characters, then blurred fake text
                    const prefix = licenseKey.startsWith('VL-') ? 'VL-' : 'VL-';
                    const firstFourChars = licenseKey.substring(licenseKey.indexOf('-') + 1, licenseKey.indexOf('-') + 5);
                    const blurredText = '<span class="blurred-text">-XXXX</span>';
                    console.log('Displaying license:', prefix + firstFourChars + blurredText);
                    licenseKeyEl.innerHTML = prefix + firstFourChars + blurredText;
                    
                    // Setup copy button if it exists
                    if (copyBtn) {
                        console.log('Setting up copy button click handler');
                        copyBtn.onclick = async function() {
                            console.log('Copy button clicked, copying:', licenseKey);
                            try {
                                await navigator.clipboard.writeText(licenseKey);
                                console.log('License key copied to clipboard');
                                // Show feedback
                                const originalHTML = copyBtn.innerHTML;
                                copyBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"></path></svg>';
                                setTimeout(() => {
                                    copyBtn.innerHTML = originalHTML;
                                }, 2000);
                            } catch (err) {
                                console.error('Failed to copy license key:', err);
                                // Fallback for older browsers
                                const textArea = document.createElement('textarea');
                                textArea.value = licenseKey;
                                document.body.appendChild(textArea);
                                textArea.select();
                                document.execCommand('copy');
                                document.body.removeChild(textArea);
                            }
                        };
                    } else {
                        console.error('Copy button not found!');
                    }
                } else {
                    licenseKeyEl.textContent = 'No license key';
                    console.log('No license key found');
                }
            } else {
                console.error('License key element not found!');
            }
        }

        // Setup menu navigation - simplified and more reliable
        function setupMenuNavigation() {
            console.log('Setting up menu navigation...');
            const menuItems = document.querySelectorAll('.vl-main-menu a');
            console.log('Found menu items:', menuItems.length);
            
            if (menuItems.length === 0) {
                console.error('No menu items found!');
                return;
            }
            
            menuItems.forEach((item, index) => {
                    const section = item.getAttribute('data-section');
                console.log(`Setting up menu item ${index}: ${section}`);
                
                // Remove href="#" to prevent hash navigation
                item.removeAttribute('href');
                
                // Add click handler directly
                item.onclick = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Menu item clicked:', section);
                    console.log('Current license key:', licenseKey);
                    
                    if (!section) {
                        console.error('No data-section attribute found on menu item');
                        return false;
                    }
                    
                    // Remove active class from all items
                    document.querySelectorAll('.vl-main-menu li').forEach(li => {
                        li.classList.remove('active');
                    });
                    
                    // Add active class to clicked item
                    item.parentElement.classList.add('active');
                    
                    // Handle section navigation
                    handleSectionNavigation(section);
                    return false;
                };
            });
        }

        // Handle section navigation
        function handleSectionNavigation(section) {
            console.log('Navigating to section:', section);
            
            // If it's the supercluster section, stay on current page
            if (section === 'supercluster') {
                // Revert to default - no highlighted galaxies
                if (typeof highlightGalaxy === 'function') {
                highlightGalaxy(null);
                }
                // Clear any URL path and show main Supercluster view
                if (licenseKey) {
                    const baseUrl = new URL(window.location.href);
                    baseUrl.searchParams.set('license', licenseKey);
                    window.history.replaceState({}, '', baseUrl.toString());
                    // Reload to show main Supercluster view
                    window.location.reload();
                }
                return;
            }
            
            // Map menu sections to galaxy names (from galaxyData)
            const sectionToGalaxyMap = {
                'web-infra': 'Website Infrastructure & Performance',
                'content': 'Content Management & Structure',
                'search-intel': 'Search Engine Intelligence',
                'reporting': 'Analytics & Engagement',
                'marketing-ads': 'Marketing & Campaign Data',
                'ecommerce': 'E-Commerce & Conversion Data',
                'security-compliance': 'Security & Compliance Data',
                'cloudops': 'CloudOps & Infrastructure Metrics',
                'user-identity': 'User & Identity Layer',
                'competitive': 'Competitive & Market Data'
            };
            
            // Get the galaxy name from the section
            const galaxyName = sectionToGalaxyMap[section];
            if (!galaxyName) {
                console.warn('Unknown section:', section);
                return;
            }
            
            if (!licenseKey) {
                console.warn('No license key available for navigation');
                return;
            }
            
            // Convert galaxy name to URL slug format (lowercase, spaces to hyphens, remove special chars)
            const slug = galaxyName
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-') // Replace non-alphanumeric with hyphens
                .replace(/^-+|-+$/g, ''); // Remove leading/trailing hyphens
            
            // Build full URL with license parameter and slug path
            // Format: ?license=VL-H59W-PDC8-ZT5W/website-infrastructure-performance/
            const baseUrl = window.location.origin + window.location.pathname;
            const newUrl = `${baseUrl}?license=${encodeURIComponent(licenseKey)}/${slug}/`;
            
            console.log('Navigating to:', newUrl);
            console.log('License key:', licenseKey);
            console.log('Slug:', slug);
            
            // Navigate to the new page
            window.location.href = newUrl;
        }

        // Highlight specific galaxy
        function highlightGalaxy(galaxyName) {
            // Remove existing highlights
            if (window.galaxyObjects) {
                window.galaxyObjects.forEach(galaxy => {
                    if (galaxy.mesh) {
                        galaxy.mesh.material.emissive.setHex(0x000000);
                        galaxy.mesh.material.opacity = 0.8;
                    }
                });
            }
            
            // Highlight the specified galaxy
            if (galaxyName && window.galaxyObjects) {
                const targetGalaxy = window.galaxyObjects.find(galaxy => 
                    galaxy.name === galaxyName
                );
                
                if (targetGalaxy && targetGalaxy.mesh) {
                    targetGalaxy.mesh.material.emissive.setHex(0x2B6AFF);
                    targetGalaxy.mesh.material.opacity = 1.0;
                }
            }
        }


        // Setup connection status
        function setupConnectionStatus() {
            const superIconImg = document.getElementById('superclusterStatusIcon');
            const connectionIcon = document.getElementById('connectionIcon');
            const connectionStatus = document.getElementById('connectionStatus');
            
            // Check VL Hub connection status
            async function checkConnectionStatus() {
                try {
                    // Try to verify authentication and license
                    const licenseKey = await verifyAuthenticationAndLicense();
                    if (!licenseKey) {
                        updateConnectionStatus(false, 'Authentication failed');
                        return;
                    }
                    
                    // Use a lightweight endpoint check instead of full data fetch
                    const endpoint = 'https://visiblelight.ai/wp-json/vl-hub/v1/constellation';
                    const url = licenseKey ? `${endpoint}?license=${encodeURIComponent(licenseKey)}` : endpoint;
                    
                    const response = await fetch(url, {
                        method: 'GET',
                        credentials: 'include',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                    });
                    
                    const isConnected = response.ok;
                    updateConnectionStatus(isConnected, isConnected ? null : `HTTP ${response.status}`);
                } catch (error) {
                    console.error('Connection check failed:', error);
                    updateConnectionStatus(false, error.message);
                }
            }
            
            // Update connection status for both widget icon and hidden status section
            function updateConnectionStatus(isConnected, error = null) {
                const checkmarkUrl = 'https://visiblelight.ai/wp-content/uploads/2025/10/checkmark.svg';
                const xIconUrl = 'https://visiblelight.ai/wp-content/uploads/2025/10/x-close-icon.svg';
                
                if (isConnected) {
                    // Update widget icon (green checkmark)
                    if (superIconImg) {
                        superIconImg.src = checkmarkUrl;
                        superIconImg.alt = 'Connected';
                        superIconImg.className = 'status-icon';
                        // Set green background on the img element itself
                        superIconImg.style.background = '#0F9900';
                        superIconImg.style.borderRadius = '50%';
                        superIconImg.style.padding = '3px';
                    }
                    
                    // Update hidden connection status section
                    if (connectionIcon) {
                        const iconImg = connectionIcon.querySelector('img');
                        if (iconImg) {
                            iconImg.src = checkmarkUrl;
                            iconImg.alt = 'check mark';
                        }
                        connectionIcon.className = 'status-icon';
                    }
                    if (connectionStatus) {
                        connectionStatus.textContent = 'Active';
                    }
                } else {
                    // Update widget icon (red X)
                    if (superIconImg) {
                        superIconImg.src = xIconUrl;
                        superIconImg.alt = 'Disconnected';
                        superIconImg.className = 'status-icon error';
                        // Set red background on the img element itself
                        superIconImg.style.background = '#f85149';
                        superIconImg.style.borderRadius = '50%';
                        superIconImg.style.padding = '3px';
                    }
                    
                    // Update hidden connection status section
                    if (connectionIcon) {
                        const iconImg = connectionIcon.querySelector('img');
                        if (iconImg) {
                            iconImg.src = xIconUrl;
                            iconImg.alt = 'error mark';
                        }
                        connectionIcon.className = 'status-icon error';
                    }
                    if (connectionStatus) {
                        connectionStatus.textContent = 'Inactive';
                    }
                }
            }

            // Check connection status immediately
            checkConnectionStatus();
            
            // Check connection status once per hour (3600000 ms)
            setInterval(checkConnectionStatus, 3600000);
        }

        // Build "Your Supercluster" summary sentence with links
        async function updateSuperclusterSummary() {
            try {
                const summaryEl = document.getElementById('superclusterSummary');
                if (!summaryEl) return;

                // Sites count from constellationData
                const sitesCount = (constellationData && typeof constellationData.total_clients === 'number')
                    ? constellationData.total_clients
                    : 0;

                // Streams and data source counts from VL Hub data-streams endpoint for current license
                let streamsCount = 0;
                let sourcesCount = 0;
                if (licenseKey) {
                    // Fetch data streams for stream count
                    const streamsResp = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/data-streams?license=${encodeURIComponent(licenseKey)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });
                    if (streamsResp.ok) {
                        const streamsData = await streamsResp.json();
                        const streams = streamsData && streamsData.streams ? streamsData.streams : {};
                        const streamArray = Array.isArray(streams) ? streams : Object.values(streams);
                        streamsCount = streamArray.length;
                    }
                    
                    // Fetch all-connections data to count all connections
                    // This endpoint returns structured connection data by category
                    const connectionsResp = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(licenseKey)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });
                    if (connectionsResp.ok) {
                        const connectionsResponse = await connectionsResp.json();
                        console.log('[Supercluster] All-connections response:', connectionsResponse);
                        
                        // Endpoint returns {ok: true, data: {...}}
                        const connectionsData = (connectionsResponse.ok && connectionsResponse.data) ? connectionsResponse.data : connectionsResponse;
                        console.log('[Supercluster] Connections data keys:', Object.keys(connectionsData || {}));
                        
                        // Count all actual connections from all-connections endpoint
                        let connectionCount = 0;
                        const connectionDetails = {};
                        
                        // Cloudflare connection (from security category)
                        if (connectionsData.cloudflare && connectionsData.cloudflare.connected === true) {
                            connectionCount += 1;
                            connectionDetails.cloudflare = true;
                        }
                        
                        // SSL/TLS Status connection (from security category)
                        if (connectionsData.ssl_tls && (connectionsData.ssl_tls.connected === true || connectionsData.ssl_tls.certificate)) {
                            connectionCount += 1;
                            connectionDetails.ssl_tls = true;
                        }
                        
                        // Liquid Web connection (from cloudops/infrastructure category)
                        if (connectionsData.liquidweb && connectionsData.liquidweb.connected === true) {
                            connectionCount += 1;
                            connectionDetails.liquidweb = true;
                        }
                        
                        // AWS S3 connection (from cloudops/infrastructure category)
                        if (connectionsData.aws_s3 && connectionsData.aws_s3.connected === true) {
                            connectionCount += 1;
                            connectionDetails.aws_s3 = true;
                        }
                        
                        // GA4 connection (from analytics category)
                        if (connectionsData.ga4 && (connectionsData.ga4.property_id || connectionsData.ga4.metrics)) {
                            connectionCount += 1;
                            connectionDetails.ga4 = true;
                        }
                        
                        // Lighthouse/PageSpeed connection - check from profile endpoint
                        // (Not included in all-connections endpoint, need to check separately)
                        
                        // Google Search Console connection (from search category)
                        if (connectionsData.gsc && connectionsData.gsc.connected === true) {
                            connectionCount += 1;
                            connectionDetails.gsc = true;
                        }
                        
                        // Competitor Reports connection (from competitive category)
                        if (connectionsData.competitor_reports && Array.isArray(connectionsData.competitor_reports) && connectionsData.competitor_reports.length > 0) {
                            connectionCount += 1;
                            connectionDetails.competitor_reports = true;
                        }
                        
                        // VLDR Metrics connection (from competitive category)
                        if (connectionsData.vldr_metrics && Object.keys(connectionsData.vldr_metrics).length > 0) {
                            connectionCount += 1;
                            connectionDetails.vldr = true;
                        }
                        
                        // WordPress Users connection (from identity category)
                        if (connectionsData.wordpress_users && connectionsData.wordpress_users.total > 0) {
                            connectionCount += 1;
                            connectionDetails.wordpress_users = true;
                        }
                        
                        // WordPress Content and Lighthouse/PageSpeed - fetch from profile endpoint
                        const profileResp = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/profile?license=${encodeURIComponent(licenseKey)}`, {
                            method: 'GET',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include'
                        });
                        if (profileResp.ok) {
                            const profileResponse = await profileResp.json();
                            const profileData = (profileResponse.ok && profileResponse.data) ? profileResponse.data : profileResponse;
                            
                            // WordPress Content connection (if content exists)
                            if (profileData.content && (profileData.content.total_posts > 0 || profileData.content.total_pages > 0 || (profileData.content.posts && profileData.content.posts.length > 0) || (profileData.content.pages && profileData.content.pages.length > 0))) {
                                connectionCount += 1;
                                connectionDetails.wordpress_content = true;
                            }
                            
                            // Lighthouse/PageSpeed connection (check if pagespeed settings exist)
                            // This is checked via get_option('vl_pagespeed_settings_' . $license_key) in PHP
                            // We can check if it exists in profile data or check separately
                            // For now, we'll check if there's any pagespeed data in the profile
                            // Note: PageSpeed might not be in profile, so we'll check it via a separate check if needed
                        }
                        
                        sourcesCount = connectionCount;
                        console.log('[Supercluster] Cloud Connections count:', sourcesCount, 'Connection details:', connectionDetails);
                        console.log('[Supercluster] Full connections data sample:', {
                            cloudflare: connectionsData.cloudflare,
                            ssl_tls: connectionsData.ssl_tls,
                            liquidweb: connectionsData.liquidweb,
                            aws_s3: connectionsData.aws_s3,
                            ga4: connectionsData.ga4,
                            gsc: connectionsData.gsc,
                            competitor_reports: connectionsData.competitor_reports,
                            vldr_metrics: connectionsData.vldr_metrics,
                            wordpress_users: connectionsData.wordpress_users
                        });
                    } else {
                        console.error('[Supercluster] All-connections fetch failed:', connectionsResp.status, connectionsResp.statusText);
                    }
                }

                // Get license key from URL for redirect
                const currentParams = new URLSearchParams(window.location.search);
                const currentLicense = currentParams.get('license') || '';
                const licenseKeyForUrl = currentLicense.split('/')[0]; // Get just the license key, not the path
                const sitesLinkHref = licenseKeyForUrl ? `?license=${encodeURIComponent(licenseKeyForUrl)}/omniscient-app-observatory/` : '#';
                const sitesLink = `<a id="sitesLink" href="${sitesLinkHref}">${sitesCount}</a>`;
                const sourcesLink = `<a id="sourcesLink" href="#">${sourcesCount}</a>`;
                const streamsLink = `<a id="streamsLink" href="#">${streamsCount}</a>`;

                // Dynamic pluralization for "Web App(s)"
                const webAppText = sitesCount === 1 ? 'Web App' : 'Web Apps';
                const galaxyText = 'Cloud Connections';
                const streamText = 'Data Streams';

                summaryEl.innerHTML = `Observing ${sitesLink} ${webAppText} spawning ${sourcesLink} ${galaxyText}, totaling ${streamsLink} ${streamText}.`;
            } catch (e) {
                const summaryEl = document.getElementById('superclusterSummary');
                if (summaryEl) summaryEl.textContent = 'Supercluster summary unavailable.';
            }
        }

        // Populate Recent Activity from VL Hub data
        async function loadRecentActivity() {
            const listEl = document.getElementById('recentActivityList');
            if (!listEl) return;

            const items = [];
            const now = Date.now();
            const withinDays = (ts, days = 7) => {
                const t = Date.parse(ts);
                return !isNaN(t) && (now - t) <= days * 24 * 60 * 60 * 1000;
            };

            // New Site Connected from constellation last_seen
            if (constellationData && Array.isArray(constellationData.clients)) {
                constellationData.clients.forEach(c => {
                    if (c.last_seen && withinDays(c.last_seen, 14)) {
                        items.push({ label: 'New Site Connected', time: c.last_seen });
                    }
                });
            }

            // Streams-based activity
            if (licenseKey) {
                try {
                    const resp = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/data-streams?license=${encodeURIComponent(licenseKey)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });
                    if (resp.ok) {
                        const data = await resp.json();
                        const streams = data && data.streams ? data.streams : {};
                        const streamArray = Array.isArray(streams) ? streams : Object.values(streams);
                        streamArray.forEach(s => {
                            if (s.connected_at && withinDays(s.connected_at, 14)) {
                                items.push({ 
                                    label: 'New Data Source Connected', 
                                    time: s.connected_at,
                                    streamName: s.name || 'Unknown Source',
                                    streamId: s.id || null,
                                    streamData: s // Store full stream data for URL building
                                });
                            }
                            if (s.last_updated && withinDays(s.last_updated, 7)) {
                                items.push({ 
                                    label: 'New Data Stream Was Synced', 
                                    time: s.last_updated,
                                    streamName: s.name || 'Unknown Stream',
                                    streamId: s.id || null,
                                    streamData: s // Store full stream data for URL building
                                });
                            }
                        });
                    }
                } catch (_) {}
            }

            // Placeholder for reports (requires hub events)
            // items.push({ label: 'New Report Run', time: new Date().toISOString() });

            // Render
            listEl.innerHTML = '';
            if (items.length === 0) {
                listEl.innerHTML = '<li class="vl-activity-empty">No recent activity.</li>';
                return;
            }
            // Sort newest first
            items.sort((a, b) => Date.parse(b.time) - Date.parse(a.time));
            for (const it of items.slice(0, 10)) {
                const when = new Date(it.time);
                const pretty = isNaN(when.getTime()) ? '' : when.toLocaleString();
                const li = document.createElement('li');
                li.className = 'vl-activity-item';
                
                // Create structure: date/time above, activity label below
                if (pretty) {
                    const timeSpan = document.createElement('span');
                    timeSpan.id = 'activityTimeStamp';
                    timeSpan.textContent = pretty;
                    li.appendChild(timeSpan);
                    li.appendChild(document.createElement('br'));
                }
                
                // Build the label - just use the label text
                const labelText = it.label;
                
                // Create text node for the base label
                const labelTextNode = document.createTextNode(labelText);
                li.appendChild(labelTextNode);
                
                // If stream name exists, add a line break and then the stream name
                if (it.streamName) {
                    // Add line break
                    li.appendChild(document.createElement('br'));
                    
                    // If stream has an ID, make it clickable
                    if (it.streamId) {
                        const streamLink = document.createElement('a');
                        streamLink.href = `#stream-${it.streamId}`;
                        streamLink.textContent = it.streamName;
                        streamLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            // Navigate to data stream page with proper URL structure
                            const streamUrl = buildStreamDataUrl(licenseKey, it.streamData || it);
                            window.location.href = streamUrl;
                        });
                        li.appendChild(streamLink);
                    } else {
                        // If stream name exists but no ID, just show it as text
                        const streamNameText = document.createTextNode(it.streamName);
                        li.appendChild(streamNameText);
                    }
                }
                
                listEl.appendChild(li);
            }
        }

        // Setup client dropdown functionality - simplified and more reliable
        function setupClientDropdown() {
            console.log('Setting up client dropdown...');
            
            // Get elements
            const dropdownArrow = document.getElementById('clientDropdownArrow');
            const dropdownLightbox = document.getElementById('clientDropdownLightbox');
            const dropdownContent = document.getElementById('clientDropdownContent');
            const accountSettings = document.getElementById('accountSettings');
            const logoutOption = document.getElementById('logoutOption');
            const logoutModal = document.getElementById('logoutModal');
            const logoutCancel = document.getElementById('logoutCancel');
            const logoutConfirm = document.getElementById('logoutConfirm');
            
            console.log('Dropdown elements:', {
                arrow: !!dropdownArrow,
                lightbox: !!dropdownLightbox,
                content: !!dropdownContent,
                accountSettings: !!accountSettings,
                logoutOption: !!logoutOption,
                logoutModal: !!logoutModal
            });

            if (!dropdownArrow || !dropdownLightbox || !dropdownContent) {
                console.error('Dropdown elements not found!');
                return;
            }

            // Make arrow clickable
            dropdownArrow.style.cursor = 'pointer';
            dropdownArrow.style.userSelect = 'none';
            
            // Position dropdown content near the arrow
            function positionDropdown() {
                const arrowRect = dropdownArrow.getBoundingClientRect();
                dropdownContent.style.top = (arrowRect.bottom + 5) + 'px';
                dropdownContent.style.left = (arrowRect.left - 100) + 'px';
            }

            // Toggle dropdown
            function toggleDropdown() {
                console.log('toggleDropdown called');
                const isVisible = dropdownLightbox.style.display === 'block';
                
                if (isVisible) {
                    dropdownLightbox.style.display = 'none';
                    console.log('Hiding dropdown');
                } else {
                    positionDropdown();
                    dropdownLightbox.style.display = 'block';
                    console.log('Showing dropdown');
                }
            }

            // Close dropdown
            function closeDropdown() {
                dropdownLightbox.style.display = 'none';
            }

            // Show logout modal
            function showLogoutModal() {
                console.log('Showing logout modal');
                logoutModal.style.display = 'block';
            }

            // Hide logout modal
            function hideLogoutModal() {
                logoutModal.style.display = 'none';
            }

            // Perform logout
            function performLogout() {
                console.log('Performing logout...');
                localStorage.removeItem('vl-cms-data');
                localStorage.removeItem('vl-supercluster-tutorial-completed');
                sessionStorage.clear();
                if (inactivityTimeout) clearTimeout(inactivityTimeout);
                window.location.href = LOGIN_PAGE_URL;
            }

            // Direct onclick handler on arrow - most reliable
            dropdownArrow.onclick = function(e) {
                console.log('Dropdown arrow clicked');
                e.preventDefault();
                    e.stopPropagation();
                    toggleDropdown();
                return false;
            };
            
            // Also add to image if it exists
            const arrowImage = dropdownArrow.querySelector('img');
            if (arrowImage) {
                arrowImage.style.pointerEvents = 'auto';
                arrowImage.onclick = function(e) {
                    console.log('Arrow image clicked');
                    e.preventDefault();
                    e.stopPropagation();
                    toggleDropdown();
                    return false;
                };
            }

            // Account Settings click
            if (accountSettings) {
                accountSettings.onclick = function(e) {
                    e.preventDefault();
                    closeDropdown();
                };
            }

            // Logout option click
            if (logoutOption) {
                logoutOption.onclick = function(e) {
                    console.log('Logout option clicked');
                    e.preventDefault();
                    e.stopPropagation();
                    closeDropdown();
                    showLogoutModal();
                };
            }

            // Logout modal buttons
            if (logoutCancel) {
                logoutCancel.onclick = hideLogoutModal;
            }

            if (logoutConfirm) {
                logoutConfirm.onclick = performLogout;
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                const target = e.target;
                const lightbox = document.getElementById('clientDropdownLightbox');
                const arrow = document.getElementById('clientDropdownArrow');
                const modal = document.getElementById('logoutModal');
                
                if (lightbox && lightbox.style.display === 'block') {
                    if (!lightbox.contains(target) && 
                        !arrow.contains(target) && 
                        (!modal || !modal.contains(target))) {
                    closeDropdown();
                    }
                }
            });

            // Update position on resize
            window.addEventListener('resize', positionDropdown);
        }

        // Tutorial system for first-time users
        const tutorialSteps = [
            {
                title: 'Welcome to Visible Light',
                description: 'This is Supercluster - the center of your digital universe. It connects all your cloud services, data streams, and analytics into one intuitive and interactive virtual interface.',
                targetElement: null, // No specific target, show welcome message
                position: 'center'
            },
            {
                title: 'Interactive 3D Visualization',
                description: 'Explore your data universe! Click and drag to rotate, scroll to zoom, and click on any galaxy to see detailed information about that data source.',
                targetElement: '#vlSuperclusterRoot',
                position: 'center'
            },
            {
                title: 'Navigation Menu',
                description: 'Access different sections of your dashboard: Web & Infra, Content, Search Intel, Reporting, Marketing & Ads, and more. Each section shows relevant data streams.',
                targetElement: '.vl-main-menu',
                position: 'left'
            },
            {
                title: 'Your License Key',
                description: 'Your unique Visible Light license key is displayed here. Click the copy button to copy it to your clipboard when needed.',
                targetElement: '#licenseKeyContainer',
                position: 'left'
            },
            {
                title: 'Recent Activity',
                description: 'Stay updated with your latest data stream syncs, new connections, and important events. Click on any activity to view detailed information.',
                targetElement: '#recentActivityWidget',
                position: 'right'
            },
            {
                title: 'Control Buttons',
                description: 'Use these controls to navigate your Supercluster: Move left/right, zoom in/out to explore different views of your data.',
                targetElement: '.vl-controls',
                position: 'right'
            },
            {
                title: 'Client Menu',
                description: 'Click on your name or the dropdown arrow to access account settings and logout options.',
                targetElement: '#clientDropdownArrow',
                position: 'top-left'
            },
            {
                title: 'You\'re All Set!',
                description: 'You now know the basics of your Supercluster dashboard. Start exploring your data universe and discover insights across all your connected sources.',
                targetElement: null,
                position: 'center'
            }
        ];

        let currentTutorialStep = 0;
        let tutorialActive = false;

        // Store username for tutorial label
        let tutorialUsername = null;

        // Update "Never show again" label with username
        function updateNeverShowLabel() {
            const label = document.getElementById('tutorialNeverShowLabel');
            if (label) {
                if (tutorialUsername) {
                    label.textContent = `Never show this tutorial again for ${tutorialUsername}`;
                } else {
                    label.textContent = 'Never show this tutorial again';
                }
            }
        }

        // Check if user has completed tutorial before
        async function checkAndShowTutorial() {
            console.log('=== TUTORIAL CHECK START ===');
            console.log('License key:', licenseKey);
            
            // Check localStorage first (faster)
            const localCompleted = localStorage.getItem('vl-supercluster-tutorial-completed');
            console.log('LocalStorage tutorial status:', localCompleted);
            
            try {
                // Include license key in request for cookie-less fallback
                const sessionUrl = new URL('https://visiblelight.ai/wp-json/vl-hub/v1/tutorial-status');
                if (licenseKey) {
                    sessionUrl.searchParams.set('license', licenseKey);
                }
                
                console.log('Checking tutorial status from server:', sessionUrl.toString());
                
                // Check server-side (survives cache/cookie clearing)
                const response = await fetch(sessionUrl.toString(), {
                    method: 'GET',
                    credentials: 'include',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });

                console.log('Tutorial status response:', response.status);

                if (response.ok) {
                    const data = await response.json();
                    console.log('Tutorial status data from server:', data);
                    
                    // Store username for label
                    if (data && data.username) {
                        tutorialUsername = data.username;
                        console.log('Tutorial username:', tutorialUsername);
                        // Immediately update client greeting with the same username
                        updateClientName();
                    }
                    
                    // If user has opted to never show tutorial, don't show it
                    if (data && data.never_show === true) {
                        console.log('✗ User has opted to never show tutorial - NOT SHOWING');
                        return;
                    }
                    // If tutorial was completed but not "never show", don't show it
                    if (data && data.completed === true) {
                        console.log('✗ Tutorial already completed on server - NOT SHOWING');
                        // Also set in localStorage for faster check next time
                        localStorage.setItem('vl-supercluster-tutorial-completed', 'true');
                        return;
                    }
                    
                    // If server says not completed, show tutorial (even if localStorage says completed)
                    console.log('✓ Server says tutorial not completed - WILL SHOW');
                } else {
                    console.warn('Tutorial status check failed:', response.status);
                    const errorText = await response.text();
                    console.warn('Error response:', errorText);
                    
                    // If server check fails, only trust localStorage if it exists
                    if (localCompleted) {
                        console.log('✗ Server check failed, but localStorage says completed - NOT SHOWING');
                        return;
                    }
                    console.log('✓ Server check failed, no localStorage - WILL SHOW');
                }
            } catch (error) {
                console.warn('Could not check tutorial status from server:', error);
                // If server check fails, only trust localStorage if it exists
                if (localCompleted) {
                    console.log('✗ Server check failed, but localStorage says completed - NOT SHOWING');
                    return;
                }
                console.log('✓ Server check failed, no localStorage - WILL SHOW');
            }

            // Show tutorial after a short delay to let page load
            console.log('=== SHOWING TUTORIAL ===');
            setTimeout(() => {
                showTutorial();
            }, 1500);
        }

        // Show tutorial
        function showTutorial() {
            const overlay = document.getElementById('tutorialOverlay');
            if (!overlay) return;
            
            tutorialActive = true;
            overlay.style.display = 'block';
            currentTutorialStep = 0;
            updateTutorialStep();
        }

        // Save tutorial status to server
        async function saveTutorialStatus(completed, neverShow) {
            // Mark tutorial as completed in localStorage
            if (completed) {
                localStorage.setItem('vl-supercluster-tutorial-completed', 'true');
            }
            
            // Save to server-side (survives cache/cookie clearing)
            try {
                // Include license key in request for cookie-less fallback
                const saveUrl = new URL('https://visiblelight.ai/wp-json/vl-hub/v1/tutorial-status');
                if (licenseKey) {
                    saveUrl.searchParams.set('license', licenseKey);
                }
                
                const response = await fetch(saveUrl.toString(), {
                    method: 'POST',
                    credentials: 'include',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        completed: completed,
                        never_show: neverShow
                    }),
                });

                if (response.ok) {
                    console.log('Tutorial status saved to server');
                    return true;
                } else {
                    console.warn('Failed to save tutorial status to server');
                    return false;
                }
            } catch (error) {
                console.warn('Error saving tutorial status to server:', error);
                return false;
            }
        }

        // Hide tutorial
        async function hideTutorial() {
            const overlay = document.getElementById('tutorialOverlay');
            if (!overlay) return;
            
            tutorialActive = false;
            overlay.style.display = 'none';
            clearHighlight();
            
            // Check if "never show again" is checked
            const neverShowCheckbox = document.getElementById('tutorialNeverShow');
            const neverShow = neverShowCheckbox && neverShowCheckbox.checked;
            
            // Save tutorial as completed (only if we reached the end)
            const isCompleted = currentTutorialStep >= tutorialSteps.length - 1;
            await saveTutorialStatus(isCompleted, neverShow);
        }

        // Update tutorial step display
        function updateTutorialStep() {
            if (currentTutorialStep < 0 || currentTutorialStep >= tutorialSteps.length) {
                hideTutorial();
                return;
            }

            const step = tutorialSteps[currentTutorialStep];
            const stepContent = document.getElementById('tutorialStepContent');
            const prevBtn = document.getElementById('tutorialPrev');
            const nextBtn = document.getElementById('tutorialNext');
            const progress = document.getElementById('tutorialProgress');

            if (!stepContent || !prevBtn || !nextBtn || !progress) return;

            // Update content
            stepContent.innerHTML = `
                <h3 class="tutorial-title">${step.title}</h3>
                <p class="tutorial-description">${step.description}</p>
            `;

            // Update navigation buttons
            prevBtn.style.display = currentTutorialStep === 0 ? 'none' : 'inline-block';
            nextBtn.textContent = currentTutorialStep === tutorialSteps.length - 1 ? 'Get Started' : 'Next';

            // Show "Never show again" option on last step
            const optionsDiv = document.getElementById('tutorialOptions');
            if (optionsDiv) {
                if (currentTutorialStep === tutorialSteps.length - 1) {
                    optionsDiv.style.display = 'block';
                    // Update label with username if available
                    updateNeverShowLabel();
                } else {
                    optionsDiv.style.display = 'none';
                }
            }

            // Update progress bar
            const progressPercent = ((currentTutorialStep + 1) / tutorialSteps.length) * 100;
            progress.style.setProperty('--progress-width', `${progressPercent}%`);

            // Highlight target element if specified
            if (step.targetElement) {
                highlightElement(step.targetElement, step.position);
            } else {
                clearHighlight();
            }
        }

        // Highlight a specific element
        function highlightElement(selector, position) {
            const element = document.querySelector(selector);
            if (!element) {
                clearHighlight();
                return;
            }

            const highlight = document.getElementById('tutorialHighlight');
            const backdrop = document.getElementById('tutorialBackdrop');
            const content = document.getElementById('tutorialContent');

            if (!highlight || !backdrop || !content) return;

            const rect = element.getBoundingClientRect();
            const padding = 10;

            // Calculate highlight position and size
            highlight.style.width = (rect.width + padding * 2) + 'px';
            highlight.style.height = (rect.height + padding * 2) + 'px';
            highlight.style.left = (rect.left - padding) + 'px';
            highlight.style.top = (rect.top - padding) + 'px';
            highlight.style.display = 'block';
            highlight.style.borderRadius = '8px';

            // Position tutorial content based on position preference
            positionContent(content, rect, position);
        }

        // Position tutorial content relative to highlighted element
        function positionContent(content, rect, position) {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const contentWidth = 400;
            const contentHeight = 200;
            const margin = 20;

            let left, top;

            switch (position) {
                case 'left':
                    left = rect.left - contentWidth - margin;
                    top = rect.top + (rect.height / 2) - (contentHeight / 2);
                    break;
                case 'right':
                    left = rect.right + margin;
                    top = rect.top + (rect.height / 2) - (contentHeight / 2);
                    break;
                case 'top':
                    left = rect.left + (rect.width / 2) - (contentWidth / 2);
                    top = rect.top - contentHeight - margin;
                    break;
                case 'bottom':
                    left = rect.left + (rect.width / 2) - (contentWidth / 2);
                    top = rect.bottom + margin;
                    break;
                case 'top-left':
                    left = rect.left;
                    top = rect.top - contentHeight - margin;
                    break;
                case 'center':
                default:
                    left = (viewportWidth / 2) - (contentWidth / 2);
                    top = (viewportHeight / 2) - (contentHeight / 2);
                    break;
            }

            // Ensure content stays within viewport
            left = Math.max(margin, Math.min(left, viewportWidth - contentWidth - margin));
            top = Math.max(margin, Math.min(top, viewportHeight - contentHeight - margin));

            content.style.left = left + 'px';
            content.style.top = top + 'px';
        }

        // Clear highlight
        function clearHighlight() {
            const highlight = document.getElementById('tutorialHighlight');
            if (highlight) {
                highlight.style.display = 'none';
            }
        }

        // Setup tutorial event listeners - simplified with direct onclick handlers
        function setupTutorial() {
            console.log('Setting up tutorial event listeners...');
            const closeBtn = document.getElementById('tutorialClose');
            const prevBtn = document.getElementById('tutorialPrev');
            const nextBtn = document.getElementById('tutorialNext');
            const backdrop = document.getElementById('tutorialBackdrop');

            console.log('Tutorial elements:', {
                closeBtn: !!closeBtn,
                prevBtn: !!prevBtn,
                nextBtn: !!nextBtn,
                backdrop: !!backdrop
            });

            if (!closeBtn || !prevBtn || !nextBtn) {
                console.error('Tutorial buttons not found!');
                return;
            }

            // Close button - direct onclick handler
            closeBtn.onclick = function(e) {
                console.log('Tutorial close button clicked');
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                // Save tutorial as seen (but not completed) when closed early
                saveTutorialStatus(false, false).catch(err => console.error('Error saving tutorial status:', err));
                hideTutorial();
                return false;
            };

            // Previous button - direct onclick handler
            prevBtn.onclick = function(e) {
                console.log('Tutorial previous button clicked, current step:', currentTutorialStep);
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                if (currentTutorialStep > 0) {
                    currentTutorialStep--;
                    console.log('Moving to step:', currentTutorialStep);
                    updateTutorialStep();
                }
                return false;
            };

            // Next button - direct onclick handler
            nextBtn.onclick = function(e) {
                console.log('Tutorial next button clicked, current step:', currentTutorialStep, 'total steps:', tutorialSteps.length);
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                if (currentTutorialStep < tutorialSteps.length - 1) {
                    currentTutorialStep++;
                    console.log('Moving to step:', currentTutorialStep);
                    updateTutorialStep();
                } else {
                    console.log('Reached last step, hiding tutorial');
                    hideTutorial();
                }
                return false;
            };

            // Close on backdrop click
            if (backdrop) {
                backdrop.onclick = function(e) {
                    // Only close if clicking directly on backdrop, not on content
                    if (e.target === backdrop) {
                        console.log('Tutorial backdrop clicked');
                        hideTutorial();
                    }
                };
            }
        }

        // Update tutorial positioning on window resize
        window.addEventListener('resize', () => {
            if (tutorialActive && currentTutorialStep >= 0 && currentTutorialStep < tutorialSteps.length) {
                const step = tutorialSteps[currentTutorialStep];
                if (step.targetElement) {
                    highlightElement(step.targetElement, step.position);
                }
            }
        });

        // Setup control buttons
        function setupControlButtons() {
            // Left/Right controls
            const controlLeft = document.getElementById('controlLeft');
            const controlRight = document.getElementById('controlRight');
            
            if (controlLeft) {
                controlLeft.addEventListener('click', () => {
                    // Move supercluster left
                    if (camera) {
                        camera.position.x -= 2;
                        camera.lookAt(0, 0, 0);
                    }
                });
            }
            
            if (controlRight) {
                controlRight.addEventListener('click', () => {
                    // Move supercluster right
                    if (camera) {
                        camera.position.x += 2;
                        camera.lookAt(0, 0, 0);
                    }
                });
            }

            // Zoom controls
            const controlZoomIn = document.getElementById('controlZoomIn');
            const controlZoomOut = document.getElementById('controlZoomOut');
            
            if (controlZoomIn) {
                controlZoomIn.addEventListener('click', () => {
                    // Zoom in
                    if (camera) {
                        camera.position.multiplyScalar(0.9);
                    }
                });
            }
            
            if (controlZoomOut) {
                controlZoomOut.addEventListener('click', () => {
                    // Zoom out
                    if (camera) {
                        camera.position.multiplyScalar(1.1);
                    }
                });
            }

        }

        // Build stream data URL with proper format
        function buildStreamDataUrl(licenseKey, streamData) {
            const baseUrl = window.location.origin + window.location.pathname;
            const urlParams = new URLSearchParams(window.location.search);
            
            // Determine category from stream categories
            let category = 'competitive'; // default
            if (streamData.categories && Array.isArray(streamData.categories)) {
                // Map categories to URL segments
                const categoryMap = {
                    'competitive': 'competitive',
                    'search': 'search-intel',
                    'analytics': 'reporting',
                    'marketing': 'marketing-ads',
                    'ecommerce': 'ecommerce',
                    'security': 'security-compliance',
                    'cloudops': 'cloudops',
                    'identity': 'user-identity',
                    'content': 'content',
                    'infrastructure': 'web-infra'
                };
                
                for (const cat of streamData.categories) {
                    if (categoryMap[cat]) {
                        category = categoryMap[cat];
                        break;
                    }
                }
            }
            
            // Determine stream type (e.g., 'competitive-analysis', 'lighthouse-insights', etc.)
            let streamType = 'data-stream';
            if (streamData.id) {
                // Map stream IDs to stream types
                if (streamData.id.includes('competitor_') || streamData.id.includes('competitive')) {
                    streamType = 'competitive-analysis';
                } else if (streamData.id.includes('lighthouse_') || streamData.id.includes('pagespeed')) {
                    streamType = 'lighthouse-insights';
                } else if (streamData.id.includes('aws_s3')) {
                    streamType = 'aws-s3-storage';
                } else if (streamData.id.includes('liquidweb')) {
                    streamType = 'liquid-web-assets';
                } else if (streamData.id.includes('google_search_console')) {
                    streamType = 'google-search-console';
                        } else {
                    streamType = streamData.id.replace(/[^a-z0-9-]/gi, '-').toLowerCase();
                }
            }
            
            // Get unique identifier
            let uniqueId = streamData.id || streamData.streamId || 'unknown';
            // For competitor analysis, use the competitor URL
            if (streamData.competitor_url) {
                uniqueId = encodeURIComponent(streamData.competitor_url);
            } else if (streamData.source_url) {
                uniqueId = encodeURIComponent(streamData.source_url);
            } else if (streamData.url) {
                uniqueId = encodeURIComponent(streamData.url);
            } else {
                uniqueId = encodeURIComponent(uniqueId);
            }
            
            // Build URL: ?license=XXX/category/data-stream/stream-type/unique-id
            const pathSegments = `${category}/data-stream/${streamType}/${uniqueId}`;
            return `${baseUrl}?license=${encodeURIComponent(licenseKey)}/${pathSegments}`;
        }

        // Check for category-level page URL (e.g., ?license=XXX/website-infrastructure-performance/)
        function checkUrlForCategoryPage() {
            const urlParams = new URLSearchParams(window.location.search);
            const licenseParam = urlParams.get('license');
            
            if (!licenseParam) return false;
            
            // Check if URL contains category path: license=XXX/category-slug/
            // Pattern: license key followed by /category-slug/ (ends with /)
            const categoryMatch = licenseParam.match(/^([^/]+)\/([^/]+)\/?$/);
            if (!categoryMatch) {
                return false;
            }
            
            const [, extractedLicense, categorySlug] = categoryMatch;
            
            // Verify license matches authenticated user
            if (extractedLicense !== licenseKey) {
                console.error('License mismatch in URL');
                return false;
            }
            
            // Render the category page
            renderCategoryPage(licenseKey, categorySlug);
            return true;
        }
        
        // Check for stream data page URL and render data stream page
        function checkUrlForStreamDataPage() {
            const urlParams = new URLSearchParams(window.location.search);
            const licenseParam = urlParams.get('license');
            
            if (!licenseParam) return false;
            
            // Check if URL contains data stream path: license=XXX/category/data-stream/stream-type/unique-id
            const pathMatch = licenseParam.match(/^([^/]+)\/([^/]+)\/data-stream\/([^/]+)\/(.+)$/);
            if (!pathMatch) {
                // Old format: ?license=XXX&stream=YYY
                const streamId = urlParams.get('stream');
                if (streamId && licenseKey) {
                    // Legacy support - redirect to new format
                    return false;
                }
                return false;
            }
            
            const [, extractedLicense, category, streamType, uniqueId] = pathMatch;
            
            // Verify license matches authenticated user
            if (extractedLicense !== licenseKey) {
                console.error('License mismatch in URL');
                return false;
            }
            
            // Render the data stream page
            renderStreamDataPage(licenseKey, category, streamType, decodeURIComponent(uniqueId));
            return true;
        }
        
        // Render category page - shows all streams/data for a category
        async function renderCategoryPage(licenseKey, categorySlug) {
            console.log('Rendering category page:', { licenseKey, categorySlug });
            
            // Hide the Supercluster visualization (Three.js canvas only)
            const rootContainer = document.getElementById('vlSuperclusterRoot');
            if (rootContainer) {
                rootContainer.style.display = 'none';
            }
            
            // Show the page content container
            const pageContent = document.getElementById('vlPageContent');
            if (pageContent) {
                pageContent.style.display = 'block';
            }
            
            // Ensure body has black background
            document.body.style.backgroundColor = '#00000000';
            
            // Map category slug to galaxy name
            const slugToGalaxyMap = {
                'website-infrastructure-performance': 'Website Infrastructure & Performance',
                'content-management-structure': 'Content Management & Structure',
                'search-engine-intelligence': 'Search Engine Intelligence',
                'analytics-engagement': 'Analytics & Engagement',
                'marketing-campaign-data': 'Marketing & Campaign Data',
                'e-commerce-conversion-data': 'E-Commerce & Conversion Data',
                'security-compliance-data': 'Security & Compliance Data',
                'cloudops-infrastructure-metrics': 'CloudOps & Infrastructure Metrics',
                'user-identity-layer': 'User & Identity Layer',
                'competitive-market-data': 'Competitive & Market Data'
            };
            
            const galaxyName = slugToGalaxyMap[categorySlug] || categorySlug;
            
            // Find the galaxy data
            const galaxy = galaxyData.find(g => g.name === galaxyName);
            if (!galaxy) {
                document.body.innerHTML = '<div><h1>Category Not Found</h1><p>Unable to find category: ' + categorySlug + '</p></div>';
                return;
            }
            
            // Fetch all streams for this category
            try {
                const streamsResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/data-streams?license=${encodeURIComponent(licenseKey)}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                
                if (!streamsResponse.ok) {
                    throw new Error('Failed to fetch stream data');
                }
                
                const streamsData = await streamsResponse.json();
                const streams = streamsData && streamsData.streams ? streamsData.streams : {};
                const streamArray = Array.isArray(streams) ? streams : Object.values(streams);
                
                // Filter streams by category (match datasetSlugs)
                const categoryStreams = streamArray.filter(s => {
                    if (!s.categories || !Array.isArray(s.categories)) return false;
                    // Check if any stream category matches any galaxy dataset slug
                    return s.categories.some(cat => 
                        galaxy.datasetSlugs.some(slug => 
                            cat.toLowerCase().includes(slug.toLowerCase()) || 
                            slug.toLowerCase().includes(cat.toLowerCase())
                        )
                    );
                });
                
                // Build HTML
                let html = '<div class="category-page-content">';
                html += '<h1>' + galaxyName + '</h1>';
                html += '<p>' + (galaxy.description || galaxy.fallbackDescription || '') + '</p>';
                
                if (categoryStreams.length === 0) {
                    html += '<p>No data streams found for this category.</p>';
                } else {
                    html += '<h2>Data Streams (' + categoryStreams.length + ')</h2>';
                    html += '<div class="streams-grid">';
                    
                    categoryStreams.forEach(stream => {
                        html += '<div class="stream-card">';
                        html += '<h3>' + (stream.name || 'Unnamed Stream') + '</h3>';
                        html += '<div><strong>Stream ID:</strong> ' + (stream.id || 'N/A') + '</div>';
                        html += '<div><strong>Health Score:</strong> ' + (stream.health_score || 'N/A') + '</div>';
                        html += '<div><strong>Status:</strong> ' + (stream.status || 'N/A') + '</div>';
                        if (stream.last_updated) {
                            html += '<div><strong>Last Updated:</strong> ' + stream.last_updated + '</div>';
                        }
                        // Add link to view stream details
                        const streamUrl = buildStreamDataUrl(licenseKey, stream);
                        html += '<div class="stream-link"><a href="' + streamUrl + '">View Stream Details</a></div>';
                        html += '</div>';
                    });
                    
                    html += '</div>';
                }
                
                html += '</div>';
                
                // Insert content into page content container (preserving overlay)
                const pageContent = document.getElementById('vlPageContent');
                if (pageContent) {
                    pageContent.innerHTML = html;
            } else {
                    console.error('Page content container not found');
                }
            } catch (error) {
                console.error('Error rendering category page:', error);
                const pageContent = document.getElementById('vlPageContent');
                if (pageContent) {
                    pageContent.innerHTML = '<div class="error-content"><h1>Error</h1><p>Failed to load category data: ' + error.message + '</p></div>';
                }
            }
        }

        // Render stream data page - replaces Supercluster visualization with data stream view
        async function renderStreamDataPage(licenseKey, category, streamType, uniqueId) {
            console.log('Rendering stream data page:', { licenseKey, category, streamType, uniqueId });
            
            // Hide the Supercluster visualization (Three.js canvas only)
            const rootContainer = document.getElementById('vlSuperclusterRoot');
            if (rootContainer) {
                rootContainer.style.display = 'none';
            }
            
            // Show the page content container
            const pageContent = document.getElementById('vlPageContent');
            if (pageContent) {
                pageContent.style.display = 'block';
            }
            
            // Ensure body has black background
            document.body.style.backgroundColor = '#00000000';
            
            // Fetch stream data from VL Hub
            try {
                const streamsResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/data-streams?license=${encodeURIComponent(licenseKey)}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                
                if (!streamsResponse.ok) {
                    throw new Error('Failed to fetch stream data');
                }
                
                const streamsData = await streamsResponse.json();
                const streams = streamsData && streamsData.streams ? streamsData.streams : {};
                const streamArray = Array.isArray(streams) ? streams : Object.values(streams);
                
                // Find the matching stream
                let stream = null;
                if (streamType === 'competitive-analysis') {
                    // For competitor analysis, find by competitor_url, source_url, or name
                    stream = streamArray.find(s => {
                        // Check if stream name contains the competitor URL
                        if (s.name && s.name.includes(uniqueId)) {
                            return true;
                        }
                        // Check various URL fields
                        if (s.competitor_url === uniqueId || 
                            s.source_url === uniqueId || 
                            s.url === uniqueId) {
                            return true;
                        }
                        // Check report_data
                        if (s.report_data && (
                            s.report_data.competitor_url === uniqueId ||
                            s.report_data.url === uniqueId
                        )) {
                            return true;
                        }
                        // Check if stream ID contains competitor URL
                        if (s.id && s.id.includes(uniqueId.replace(/[^a-zA-Z0-9]/g, '_'))) {
                            return true;
                        }
                        return false;
                    });
            } else {
                    // For other streams, find by ID or URL
                    stream = streamArray.find(s => 
                        s.id === uniqueId || 
                        s.source_url === uniqueId || 
                        s.url === uniqueId ||
                        s.competitor_url === uniqueId ||
                        (s.name && s.name.includes(uniqueId))
                    );
                }
                
                if (!stream) {
                    // Try to find by stream ID pattern
                    const streamIdPattern = streamType.replace(/-/g, '_');
                    stream = streamArray.find(s => s.id && s.id.includes(streamIdPattern));
                }
                
                // If still not found and it's a competitor analysis, try to find any competitor stream
                if (!stream && streamType === 'competitive-analysis') {
                    stream = streamArray.find(s => 
                        s.id && s.id.includes('competitor') ||
                        (s.categories && s.categories.includes('competitive'))
                    );
                }
                
                if (!stream) {
                    const pageContent = document.getElementById('vlPageContent');
                    if (pageContent) {
                        pageContent.innerHTML = '<div class="error-content"><h1>Stream Data Not Found</h1><p>Unable to find stream data for: ' + uniqueId + '</p></div>';
                    }
                    return;
                }
                
                // For competitor analysis, also fetch detailed report from database
                if (streamType === 'competitive-analysis' && uniqueId) {
                    try {
                        const reportResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/competitor-report?license=${encodeURIComponent(licenseKey)}&competitor_url=${encodeURIComponent(uniqueId)}`, {
                            method: 'GET',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include'
                        });
                        
                        if (reportResponse.ok) {
                            const reportData = await reportResponse.json();
                            if (reportData && reportData.success && reportData.report) {
                                // Merge report data into stream
                                stream.report_data = reportData.report;
                            }
                        }
                    } catch (reportError) {
                        console.warn('Could not fetch detailed competitor report:', reportError);
                        // Continue with stream data anyway
                    }
                }
                
                // Render the data stream page
                renderStreamDataContent(stream, uniqueId, streamType);
                
            } catch (error) {
                console.error('Error rendering stream data page:', error);
                const pageContent = document.getElementById('vlPageContent');
                if (pageContent) {
                    pageContent.innerHTML = '<div class="error-content"><h1>Error Loading Stream Data</h1><p>' + error.message + '</p></div>';
                }
            }
        }
        
        // Render stream data content (all data from VL Hub)
        function renderStreamDataContent(stream, uniqueId, streamType) {
            let html = '<div class="stream-data-page">';
            
            // Stream Header
            html += '<h1>' + (stream.name || 'Data Stream') + '</h1>';
            if (stream.description) {
                html += '<p>' + stream.description + '</p>';
            }
            
            // For competitor analysis, fetch and display competitor report data
            // Check if this is a competitor analysis stream (either by ID or by having report_data)
            const isCompetitorAnalysis = (stream.id && (stream.id.includes('competitor') || stream.id.includes('competitive'))) || 
                                         (stream.categories && stream.categories.includes('competitive')) ||
                                         streamType === 'competitive-analysis';
            
            if (isCompetitorAnalysis && stream.report_data) {
                const report = stream.report_data;
                
                // Lighthouse Scores
                if (report.lighthouse) {
                    html += '<h2>Lighthouse Scores</h2>';
                    html += '<div>';
                    html += '<div><strong>Performance:</strong> ' + (report.lighthouse.performance || 'N/A') + '%</div>';
                    html += '<div><strong>Accessibility:</strong> ' + (report.lighthouse.accessibility || 'N/A') + '%</div>';
                    html += '<div><strong>SEO:</strong> ' + (report.lighthouse.seo || 'N/A') + '%</div>';
                    html += '<div><strong>Best Practices:</strong> ' + (report.lighthouse.best_practices || 'N/A') + '%</div>';
                    html += '</div>';
                }
                
                // Site Information
                html += '<h2>Site Information</h2>';
                html += '<div>';
                html += '<div><strong>Public Pages:</strong> ' + (report.public_pages || 'N/A') + '</div>';
                if (report.blog) {
                    html += '<div><strong>Blog Status:</strong> ' + (report.blog.status || 'Unknown') + ' (' + (report.blog.post_count || 0) + ' posts detected)</div>';
                    html += '<div><strong>Blog URL:</strong> <a href="' + (report.blog.source_link || '#') + '" target="_blank">' + (report.blog.source_link || 'N/A') + '</a></div>';
                }
                if (report.meta_info) {
                    if (report.meta_info.title) {
                        html += '<div><strong>Title:</strong> ' + report.meta_info.title + '</div>';
                    }
                    if (report.meta_info.description) {
                        html += '<div><strong>Description:</strong> ' + report.meta_info.description + '</div>';
                    }
                    if (report.meta_info.keywords) {
                        html += '<div><strong>Keywords:</strong> ' + report.meta_info.keywords + '</div>';
                    }
                }
                html += '</div>';
                
                // Top Keywords
                if (report.top_keywords && Array.isArray(report.top_keywords) && report.top_keywords.length > 0) {
                    html += '<h2>Top 10 Keywords</h2>';
                    html += '<div>';
                    report.top_keywords.slice(0, 10).forEach(item => {
                        const keyword = item.keyword || item;
                        const frequency = item.frequency || '';
                        html += '<div>';
                        html += '<strong>' + keyword + '</strong>';
                        if (frequency) {
                            html += ' - Frequency: ' + frequency;
                        }
                        html += '</div>';
                    });
                    html += '</div>';
                }
                
                // Top Keyphrases
                if (report.top_keyphrases && Array.isArray(report.top_keyphrases) && report.top_keyphrases.length > 0) {
                    html += '<h2>Top 10 Keyphrases</h2>';
                    html += '<div>';
                    report.top_keyphrases.slice(0, 10).forEach(item => {
                        const phrase = item.phrase || item;
                        const frequency = item.frequency || '';
                        html += '<div>';
                        html += '<strong>' + phrase + '</strong>';
                        if (frequency) {
                            html += ' - Frequency: ' + frequency;
                        }
                        html += '</div>';
                    });
                    html += '</div>';
                }
            }
            
            // Generic stream data
            html += '<h2>Stream Details</h2>';
            html += '<div>';
            html += '<div><strong>Stream ID:</strong> ' + (stream.id || 'N/A') + '</div>';
            html += '<div><strong>Health Score:</strong> ' + (stream.health_score || 'N/A') + '</div>';
            html += '<div><strong>Status:</strong> ' + (stream.status || 'N/A') + '</div>';
            if (stream.last_updated) {
                html += '<div><strong>Last Updated:</strong> ' + stream.last_updated + '</div>';
            }
            if (stream.error_count !== undefined) {
                html += '<div><strong>Error Count:</strong> ' + stream.error_count + '</div>';
            }
            if (stream.warning_count !== undefined) {
                html += '<div><strong>Warning Count:</strong> ' + stream.warning_count + '</div>';
            }
            html += '</div>';
            
            // Display all report_data if available
            if (stream.report_data && typeof stream.report_data === 'object') {
                html += '<h2>Report Data</h2>';
                html += '<pre>' + JSON.stringify(stream.report_data, null, 2) + '</pre>';
            }
            
            html += '</div>';
            
            // Insert content into page content container (preserving overlay)
            const pageContent = document.getElementById('vlPageContent');
            if (pageContent) {
                pageContent.innerHTML = html;
            } else {
                console.error('Page content container not found');
            }
        }

        // NOTE: renderSharedLunaComposer is defined earlier in the file (before authentication check)
        // Duplicate definition removed
        
        // Render Luna Composer page
        async function renderLunaComposer() {
            try {
                console.log('[Luna Composer] Starting render...');
                
                // Remove yourSuperclusterWidget from Luna Composer page
                const superclusterWidget = document.getElementById('yourSuperclusterWidget');
                if (superclusterWidget) {
                    console.log('[Luna Composer] Removing yourSuperclusterWidget...');
                    superclusterWidget.remove();
                }
                
                // Replace right sidebar with History sidebar for Luna Composer
                const rightSidebar = document.querySelector('.vl-right-sidebar');
                if (rightSidebar) {
                    console.log('[Luna Composer] Replacing right sidebar with History...');
                    // Replace the Stream Activity widget with History widget
                    const activityWidget = rightSidebar.querySelector('#recentActivityWidget');
                    if (activityWidget) {
                        activityWidget.innerHTML = `
                            <div class="vl-widget-header">
                                <h3>History</h3>
                                <button class="vl-widget-toggle" data-widget="recentActivityWidget" aria-label="Hide widget">
                                    <img src="https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-hide-icon.svg" alt="Hide" class="vl-toggle-icon" />
                                </button>
                            </div>
                            <div class="vl-widget-body">
                                <ul id="lunaComposerHistoryList" class="vl-activity-list">
                                    <li class="vl-activity-empty">No saved documents.</li>
                                </ul>
                            </div>
                        `;
                    }
                }
                
                // Remove controls completely
                const controls = document.querySelector('.vl-controls');
                if (controls) {
                    console.log('[Luna Composer] Removing controls...');
                    controls.remove();
                }
                
                // Remove three.js labels if they exist
                const labelsContainer = document.querySelector('.vl-supercluster-labels');
                if (labelsContainer) {
                    console.log('[Luna Composer] Removing labels container...');
                    labelsContainer.remove();
                }
                
                // Remove any three.js canvas if it exists
                const rootContainer = document.getElementById('vlSuperclusterRoot');
                const pageContent = document.getElementById('vlPageContent');
                
                if (rootContainer) {
                    // Remove any canvas elements
                    const canvas = rootContainer.querySelector('canvas');
                    if (canvas) {
                        console.log('[Luna Composer] Removing canvas...');
                        canvas.remove();
                    }
                }
                
                // Show page content container (keep overlay visible)
                if (!pageContent) {
                    // Create page content container if it doesn't exist
                    const newPageContent = document.createElement('div');
                    newPageContent.id = 'vlPageContent';
                    newPageContent.className = 'vl-page-content';
                    newPageContent.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: transparent; z-index: 1; overflow-y: auto; display: block !important; pointer-events: none;';
                    document.body.appendChild(newPageContent);
                } else {
                    // Ensure page content is visible (but allow overlay to show through)
                    pageContent.style.display = 'block';
                    pageContent.style.position = 'fixed';
                    pageContent.style.top = '0';
                    pageContent.style.left = '0';
                    pageContent.style.width = '100%';
                    pageContent.style.height = '100%';
                    pageContent.style.background = 'transparent';
                    pageContent.style.zIndex = '1';
                    pageContent.style.overflowY = 'auto';
                    pageContent.style.pointerEvents = 'none';
                }
                
                // Extract license key from URL
                const currentParams = new URLSearchParams(window.location.search);
                const currentUrlLicenseParam = currentParams.get('license') || '';
                let extractedLicenseKey = '';
                if (currentUrlLicenseParam) {
                    const licenseMatch = currentUrlLicenseParam.match(/^([^/]+)/);
                    if (licenseMatch) {
                        extractedLicenseKey = licenseMatch[1];
                    } else {
                        extractedLicenseKey = currentUrlLicenseParam;
                    }
                }
                
                // Fetch Luna Chat shortcode from VL Hub profile
                let lunaShortcode = '';
                try {
                    const profileResp = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/profile?license=${encodeURIComponent(extractedLicenseKey)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });
                    if (profileResp.ok) {
                        const profileData = await profileResp.json();
                        const profile = (profileData.ok && profileData.data) ? profileData.data : profileData;
                        if (profile.luna_supercluster_shortcode) {
                            lunaShortcode = profile.luna_supercluster_shortcode;
                        }
                    }
                } catch (e) {
                    console.warn('[Luna Composer] Could not fetch shortcode from profile:', e);
                }
                
                // If no shortcode found, check if user has Luna Widget Only plugin installed
                if (!lunaShortcode) {
                    // Try to fetch from the client's WordPress site
                    // For now, we'll use a default pattern
                    lunaShortcode = `[luna_chat vl_key=${extractedLicenseKey}]`;
                }
                
                // Only show if shortcode exists
                if (!lunaShortcode || !lunaShortcode.includes('luna_chat')) {
                    const pageContentEl = document.getElementById('vlPageContent');
                    if (pageContentEl) {
                        pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Luna Composer</h1><p>Luna Chat shortcode not found in your VL Hub profile. Please add a Luna Chat shortcode to access Luna Composer.</p></div>';
                    }
                    return;
                }
                
                // Fetch canned responses from WordPress
                let cannedResponses = [];
                try {
                    const cannedResp = await fetch(`https://visiblelight.ai/wp-json/luna_widget/v1/canned-responses?license=${encodeURIComponent(extractedLicenseKey)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });
                    if (cannedResp.ok) {
                        const cannedData = await cannedResp.json();
                        cannedResponses = cannedData.items || [];
                    }
                } catch (e) {
                    console.warn('[Luna Composer] Could not fetch canned responses:', e);
                }
                
                // Build Luna Composer UI
                // Add padding-top to account for overlay header (80px) and some spacing
                // Make the container clickable (pointer-events: auto) so it can receive events
                let html = '<style>@media (min-width: 991px) { .luna-composer-page { max-width: 55% !important; } }</style>';
                html += '<style>.luna-composer-loading-text { background: linear-gradient(to right, #fff4e9 20%, #9A9793 30%, #9A9793 70%, #fff4e9 80%); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; background-size: 200% auto; animation: textShine 7s ease-in-out infinite alternate; } @keyframes textShine { to { background-position: -200%; } } .luna-composer-loading-icon { display: inline-block; width: 20px; height: 20px; margin-right: 12px; vertical-align: middle; animation: lunaComposerSpin 1s linear infinite; color: #fff4e9; opacity: 0.8; } @keyframes lunaComposerSpin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }</style>';
                html += '<div class="luna-composer-page" style="min-height: 100vh; background: transparent; color: #fff4e9; padding: 40px 0; max-width: 1200px; margin: 0 auto; position: relative; z-index: 2; pointer-events: auto;">';
                
                // Luna Composer Editor Section (Canned Prompts / Intelligent Suggestions)
                html += '<div class="luna-composer__editor" style="margin-bottom: 0; min-width: 100%;">';
                html += '<h1 class="TypeGradient" style="margin-bottom: 20px; font-size: 1.5rem;margin-top: 0;">Luna: Compose</h1>';
                html += '<div style="display: flex; align-items: center; gap: 16px; margin-bottom: 16px;">';
                html += '<div id="luna-composer-mode-toggle" data-mode="canned" style="display: flex; align-items: center; background: #2E2C2A50; border: 1px solid #5A575335; border-radius: 6px; padding: 2px; transition: all 0.2s ease;">';
                html += '<button id="luna-composer-mode-canned" onclick="window.lunaComposerToggleMode(); event.stopPropagation();" style="padding: 6px 16px; border: none; background: #2E2C2A; color: #fff4e9; border-radius: 4px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease; white-space: nowrap;"></button>';
                html += '<button id="luna-composer-mode-intelligent" onclick="window.lunaComposerToggleMode(); event.stopPropagation();" style="padding: 6px 16px; border: none; background: transparent; color: #9A9793; border-radius: 4px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease; white-space: nowrap;"></button>';
                html += '</div>';
                html += '<h2 id="luna-composer-section-title" style="color: #fff4e9; margin: 0; font-size: 1.2rem;">Canned Prompts</h2>';
                html += '</div>';
                html += '<div id="luna-composer-canned-section" style="display: block;">';
                
                if (cannedResponses.length > 0) {
                    html += '<div class="canned-prompts-wrapper" style="position: relative; width: 100%;">';
                    html += '<button class="canned-prompts-scroll-btn canned-prompts-scroll-left" style="display: none; position: absolute; left: 0; top: 44px; width: 20px; height: 20px; background: url(https://visiblelight.ai/wp-content/uploads/2025/08/left-right-arrow.svg) no-repeat center; background-size: contain; border: none; cursor: pointer; z-index: 10000; transform: rotate(180deg);" onclick="window.scrollCannedPrompts(this, -1)" aria-label="Scroll left"></button>';
                    html += '<div class="canned-prompts-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px;positon:relative;">';
                    cannedResponses.forEach(item => {
                        const escapedPrompt = (item.prompt || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
                        const escapedContent = (item.content || '').replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/\n/g, '\\n');
                        const escapedTitle = (item.title || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        const escapedExcerpt = (item.excerpt || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        html += '<div class="canned-prompt-item" data-prompt-id="' + item.id + '" style="background: #000000; border: 1px solid #2E2C2A; border-radius: 8px; padding: 16px; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.borderColor=\'#5A5753\';" onmouseout="this.style.borderColor=\'#2E2C2A\';" onclick="window.lunaComposerUsePrompt(\'' + item.id + '\', \'' + escapedPrompt + '\', \'\')">';
                        html += '<h3 style="color: #fff4e9; margin: 0 0 8px 0; font-size: 1rem; font-weight: 400;">' + escapedTitle + '</h3>';
                        html += '<p style="color: #9A9793; margin: 0; font-size: 0.875rem; line-height: 1.4;">' + escapedExcerpt + '</p>';
                        html += '</div>';
                    });
                    html += '</div>';
                    html += '<button class="canned-prompts-scroll-btn canned-prompts-scroll-right" style="position: absolute; right: 0; top: 44px; width: 20px; height: 20px; background: url(https://visiblelight.ai/wp-content/uploads/2025/08/left-right-arrow.svg) no-repeat center; background-size: contain; border: none; cursor: pointer; z-index: 10000;" onclick="window.scrollCannedPrompts(this, 1)" aria-label="Scroll right"></button>';
                    html += '</div>';
                } else {
                    html += '<p style="color: #9A9793; margin: 16px 0;">No canned prompts found. Create canned prompts in WP Admin > Luna Widget > Canned Responses.</p>';
                }
                html += '</div>'; // Close canned-prompts-wrapper
                html += '</div>'; // Close luna-composer-canned-section
                
                // Toolbar (sticky) with blur container
                html += '<div class="luna-composer-toolbar-container" style="position: sticky; top: 2rem; margin-bottom: 20px; z-index: 10; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);">';
                html += '<div class="luna-composer-toolbar" style="position: sticky; display: flex; top:0; justify-content: space-between; align-items: center; padding: 12px 12px 12px 12px">';
                html += '<div style="display: flex; align-items: center; gap: 16px;">';
                html += '<span style="color: #fff4e9; font-weight: 400; font-size: 1rem;">Options</span>';
                html += '<button id="luna-composer-find-replace" style="background: #2E2C2A50; border: 1px solid #5A575335; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;" onclick="window.lunaComposerShowFindReplace()" title="Find and Replace"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/shuffle-regular-full.svg" alt="Find and Replace" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<div class="luna-composer-share" style="position: relative; display: inline-block;">';
                html += '<button id="luna-composer-share-btn" style="background: #2E2C2A50; border: 1px solid #5A575335; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;" onclick="window.lunaComposerShowShareModal()" title="Share"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/share-regular-full.svg" alt="Share" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '</div>';
                html += '<div class="luna-composer-export" style="position: relative; display: inline-block;">';
                html += '<button id="luna-composer-export-btn" style="background: #2E2C2A50; border: 1px solid #5A575335; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.77rem; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;" onmouseover="this.style.background=\'#3A3836\';" onmouseout="this.style.background=\'#2E2C2A\';" onclick="window.lunaComposerToggleExportMenu()" title="Export to"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/arrow-down-to-line-solid-full.svg" alt="Export to" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<div id="luna-composer-export-menu" style="display: none; position: fixed; background: rgba(0,0,0,0.85) !important; backdrop-filter: blur(12px) !important; -webkit-backdrop-filter: blur(12px) !important; border: 1px solid #2E2C2A; border-radius: 6px; padding: 8px 0; min-width: 180px; z-index: 10000 !important; box-shadow: 0 4px 12px rgba(0,0,0,0.4);">';
                html += '<button onclick="window.lunaComposerExportTo(\'google-docs\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Google Docs</button>';
                html += '<button onclick="window.lunaComposerExportTo(\'pdf\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">PDF</button>';
                html += '<button onclick="window.lunaComposerExportTo(\'mp3\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Audio file (mp3)</button>';
                html += '</div>';
                html += '</div>';
                html += '<div id="luna-composer-reimagine-wrapper" style="position: relative; display: none;">';
                html += '<button id="luna-composer-reimagine-btn" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #9A9793; padding: 8px 16px; border-radius: 6px; cursor: not-allowed; font-size: 0.875rem; transition: all 0.2s ease; display: flex; pointer-events: none; align-items: center; justify-content: center; gap: 8px;" onclick="window.lunaComposerToggleReimagineMenu(event)" title="Reimagine with Luna" disabled>';
                html += '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 2L10 6L14 6L11 9L12 13L8 10L4 13L5 9L2 6L6 6L8 2Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
                html += '<span>Reimagine with Luna</span>';
                html += '<svg width="14" height="14" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-left: 4px;"><path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
                html += '</button>';
                html += '<div id="luna-composer-reimagine-menu" style="display: none; position: absolute; right: 0; top: calc(100% + 8px); background: rgba(0,0,0,0.92); border: 1px solid #2E2C2A; border-radius: 6px; min-width: 220px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.4); padding: 8px 0;">';
                html += '<button type="button" onclick="window.lunaComposerSelectReimagineMode(\'highlight\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Highlight</button>';
                html += '<button type="button" onclick="window.lunaComposerSelectReimagineMode(\'branding\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Branding</button>';
                html += '<button type="button" onclick="window.lunaComposerSelectReimagineMode(\'linguistics\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Linguistics</button>';
                html += '</div>';
                html += '</div>';
                html += '<button id="luna-composer-dictate-btn" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.77rem; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;" onclick="window.lunaComposerToggleDictate()" title="Dictate"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/microphone-regular-full-1.svg" alt="Dictate" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<button id="luna-composer-readback-btn" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.77rem; transition: all 0.2s ease;" onclick="window.lunaComposerToggleReadback()">Read Aloud</button>';
                html += '<button id="luna-composer-delete-btn" style="background: #d63638; border: 1px solid #1f1d1a; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.77rem; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;" onclick="window.lunaComposerShowDeleteModal()" title="Move to trash"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/trash-can-regular-full.svg" alt="Move to trash" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<div id="luna-composer-auto-save-status" style="display: flex; align-items: center; gap: 8px; padding-right: 0;">';
                html += '<img src="https://visiblelight.ai/wp-content/uploads/2025/11/cloud-check-regular-full.svg" alt="Auto-save" style="width: 18px; height: 18px;" />';
                html += '<span id="luna-composer-save-message" style="color: #fff4e9; font-size: 0.6rem; opacity: 0; transition: opacity 0.3s ease;"></span>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                // Text Editor (sticky) with blur container
                html += '<div class="luna-composer-editor-container" style="position: relative;">';
                html += '<div class="luna-composer-editor-toolbar-container" style="position: sticky; top: calc(0rem + 58px); z-index: 9; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); background: rgba(0,0,0, 0.7); border-right: 1px solid #1f1d1a; border-left: 1px solid #1f1d1a; border-top: 1px solid #1f1d1a; border-bottom: none; border-radius: 8px 8px 0 0;">';
                html += '<div id="luna-composer-editor-toolbar" style="display: flex; gap: 8px; padding: 12px; flex-wrap: wrap; align-items: center;">';
                html += '<button onclick="document.execCommand(\'bold\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Bold">B</button>';
                html += '<button onclick="document.execCommand(\'italic\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-style: italic; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Italic">I</button>';
                html += '<button onclick="document.execCommand(\'underline\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; text-decoration: underline; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Underline">U</button>';
                html += '<button onclick="document.execCommand(\'strikeThrough\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; text-decoration: line-through; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Strikethrough">S</button>';
                html += '<div style="width: 1px; background: #1f1d1a; margin: 0 4px; height:20px;"></div>';
                html += '<button onclick="document.execCommand(\'insertUnorderedList\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(8px);" title="Bullet List"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/list-regular-full.svg" alt="Bullet List" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<button onclick="document.execCommand(\'insertOrderedList\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(8px);" title="Numbered List"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/list-ol-solid-full-1.svg" alt="Numbered List" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<button onclick="document.execCommand(\'indent\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Indent">→</button>';
                html += '<button onclick="document.execCommand(\'outdent\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Outdent">←</button>';
                html += '<div style="width: 1px; background: #1f1d1a; margin: 0 4px; height:20px;"></div>';
                html += '<button onclick="document.execCommand(\'undo\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Undo">↶</button>';
                html += '<button onclick="document.execCommand(\'redo\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Redo">↷</button>';
                html += '<div style="flex: 1;"></div>'; // Spacer to push buttons to the right
                html += '<div style="width: 1px; background: #1f1d1a; margin: 0 4px; height:20px;"></div>'; // Separator
                html += '<button id="luna-composer-editor-heart-btn" onclick="window.lunaComposerToggleHeart()" style="display: none; background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; align-items: center; justify-content: center; backdrop-filter: blur(8px);" title="Like this document"><img id="luna-composer-heart-icon" src="https://visiblelight.ai/wp-content/uploads/2025/11/heart-regular-full-1.svg" alt="Like" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '</div>';
                html += '</div>';
                // Check if there's a document ID in the URL
                const urlParams = new URLSearchParams(window.location.search);
                const urlLicense = urlParams.get('license') || '';
                let documentId = null;
                if (urlLicense.includes('/luna/compose/')) {
                    const match = urlLicense.match(/\/luna\/compose\/([^\/]+)/);
                    if (match && match[1]) {
                        documentId = match[1];
                    }
                }
                
                html += '<div id="luna-composer-editor-wrapper" style="position: relative;">';
                html += '<div id="luna-composer-editor" contenteditable="true" style="position: sticky; top: calc(2rem + 60px + 48px); min-height: 400px; padding: 0 12px; background: #000; border-right: 1px solid #1f1d1a;border-left: 1px solid #5A575350;border-bottom: 1px solid #5A575350; border-radius: 0 0 8px 8px; color: #fff4e9; font-size: 1rem; line-height: 1.6; outline: none; word-wrap: break-word; z-index: 8;" data-license-key="' + extractedLicenseKey + '" data-document-id="' + (documentId || '') + '"></div>';
                html += '<div id="luna-composer-feedback-buttons" style="position: absolute; top: 12px; right: 12px; display: none; gap: 8px; z-index: 10; background: rgba(0,0,0,0.8); padding: 8px; border-radius: 6px; backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px);">';
                html += '<button id="luna-composer-like-btn" onclick="window.lunaComposerSubmitFeedback(\'like\')" style="background: transparent; border: 1px solid #5A5753; color: #fff4e9; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease; display: flex; align-items: center; gap: 4px;" title="Like this response" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">👍 Like</button>';
                html += '<button id="luna-composer-dislike-btn" onclick="window.lunaComposerSubmitFeedback(\'dislike\')" style="background: transparent; border: 1px solid #5A5753; color: #fff4e9; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease; display: flex; align-items: center; gap: 4px;" title="Dislike this response" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">👎 Dislike</button>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                html += '</div>';
                
                // Delete Confirmation Modal
                html += '<div id="luna-composer-delete-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10001; align-items: center; justify-content: center;">';
                html += '<div style="background: #232120; border: 1px solid #2E2C2A; border-radius: 8px; padding: 24px; max-width: 500px; width: 90%;">';
                html += '<h3 style="color: #fff4e9; margin: 0 0 16px 0; font-size: 1.25rem; font-weight: 600;">Are you sure you want to permanently delete this document?</h3>';
                html += '<p style="color: #9A9793; margin: 0 0 20px 0; font-size: 0.875rem; line-height: 1.6;">Deleting this document can not be undone. <a href="#" id="luna-composer-delete-download-link" style="color: #8D8C00; text-decoration: underline; cursor: pointer;" onclick="window.lunaComposerDownloadBackup(); return false;">Download a backup now</a> before continuing.</p>';
                html += '<div style="display: flex; gap: 12px; justify-content: flex-end;">';
                html += '<button id="luna-composer-delete-cancel" onclick="window.lunaComposerCloseDeleteModal()" style="background: #2E2C2A; border: 1px solid #5A5753; color: #fff4e9; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">Cancel</button>';
                html += '<button id="luna-composer-delete-confirm" onclick="window.lunaComposerDeleteDocument()" disabled style="background: #d63638; border: 1px solid #5A5753; color: #fff4e9; padding: 10px 20px; border-radius: 6px; cursor: not-allowed; font-size: 0.875rem; font-weight: 600; opacity: 0.5;">Delete Permanently</button>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                // Share Modal
                html += '<div id="luna-composer-share-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10001; align-items: center; justify-content: center;">';
                html += '<div style="background: #23212010; backdrop-filter: blur(8px); border: 1px solid #2E2C2A; border-radius: 8px; padding: 24px; max-width: 500px; width: 90%;">';
                html += '<h3 style="color: #fff4e9; margin: 0 0 16px 0; font-size: 1.25rem; font-weight: 600;">Share Document</h3>';
                html += '<div style="margin-bottom: 20px;">';
                html += '<label style="display: flex; align-items: center; gap: 12px; color: #fff4e9; margin-bottom: 16px; font-size: 0.875rem; cursor: pointer;">';
                html += '<input type="radio" name="share-access" value="anyone" checked style="width: 18px; height: 18px; cursor: pointer;" />';
                html += '<span>Anyone with a link can view and download</span>';
                html += '</label>';
                html += '</div>';
                html += '<div style="margin-bottom: 20px;">';
                html += '<label style="display: block; color: #fff4e9; margin-bottom: 8px; font-size: 0.875rem; font-weight: 600;">Share Link:</label>';
                html += '<div style="display: flex; gap: 8px;">';
                html += '<input type="text" id="luna-composer-share-link-input" readonly style="flex: 1; padding: 10px; background: #000; border: 1px solid #2E2C2A; border-radius: 4px; color: #fff4e9; font-size: 0.875rem; box-sizing: border-box;" />';
                html += '<button id="luna-composer-share-copy-btn" onclick="window.lunaComposerCopyShareLink()" style="background: #fff4e9; border: 1px solid #5A5753; color: #000; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; font-weight: 600; white-space: nowrap;">Copy Link</button>';
                html += '</div>';
                html += '</div>';
                html += '<div style="display: flex; gap: 12px; justify-content: flex-end;">';
                html += '<button onclick="window.lunaComposerCloseShareModal()" style="background: #2E2C2A; border: 1px solid #5A5753; color: #fff4e9; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">Close</button>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                // Find and Replace Modal
                html += '<div id="luna-composer-find-replace-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; align-items: center; justify-content: center;">';
                html += '<div style="background: #000000; border: 1px solid #2E2C2A; border-radius: 8px; padding: 24px; max-width: 500px; width: 90%;">';
                html += '<h3 style="color: #fff4e9; margin: 0 0 20px 0; font-size: 1.25rem;">Find and Replace</h3>';
                html += '<div style="margin-bottom: 16px;">';
                html += '<label style="display: block; color: #fff4e9; margin-bottom: 8px; font-size: 0.875rem;">Find:</label>';
                html += '<input type="text" id="luna-composer-find-text" style="width: 100%; padding: 10px; background: #000; border: 1px solid #2E2C2A; border-radius: 4px; color: #fff4e9; font-size: 0.875rem; box-sizing: border-box;" />';
                html += '</div>';
                html += '<div style="margin-bottom: 20px;">';
                html += '<label style="display: block; color: #fff4e9; margin-bottom: 8px; font-size: 0.875rem;">Replace with:</label>';
                html += '<input type="text" id="luna-composer-replace-text" style="width: 100%; padding: 10px; background: #000; border: 1px solid #2E2C2A; border-radius: 4px; color: #fff4e9; font-size: 0.875rem; box-sizing: border-box;" />';
                html += '</div>';
                html += '<div style="display: flex; gap: 12px; justify-content: flex-end;">';
                html += '<button onclick="window.lunaComposerCloseFindReplace()" style="background: #2E2C2A; border: 1px solid #5A5753; color: #fff4e9; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">Cancel</button>';
                html += '<button onclick="window.lunaComposerExecuteFindReplace()" style="background: #fff4e9; border: 1px solid #5A5753; color: #000; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 400;">Replace All</button>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                const pageContentEl = document.getElementById('vlPageContent');
                if (pageContentEl) {
                    console.log('[Luna Composer] Setting innerHTML, length:', html.length);
                    pageContentEl.innerHTML = html;
                    let highlightTooltip = document.getElementById('luna-composer-highlight-tooltip');
                    if (!highlightTooltip) {
                        highlightTooltip = document.createElement('div');
                        highlightTooltip.id = 'luna-composer-highlight-tooltip';
                        highlightTooltip.style.cssText = 'display: none; position: fixed; top: 0; left: 0; transform: translate(-50%, -100%); background: rgba(0,0,0,0.92); border: 1px solid #2E2C2A; border-radius: 6px; padding: 8px 12px; z-index: 20000; align-items: center; gap: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.35);';

                        const tooltipText = document.createElement('span');
                        tooltipText.textContent = 'Reimagine selection?';
                        tooltipText.style.cssText = 'color: #fff4e9; font-size: 0.75rem;';

                        const actionButton = document.createElement('button');
                        actionButton.id = 'luna-composer-highlight-action';
                        actionButton.textContent = 'Reimagine';
                        actionButton.style.cssText = 'background: #2E2C2A; border: none; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.75rem; transition: background 0.2s ease;';
                        actionButton.addEventListener('mouseenter', () => {
                            actionButton.style.background = '#3A3836';
                        });
                        actionButton.addEventListener('mouseleave', () => {
                            actionButton.style.background = '#2E2C2A';
                        });

                        highlightTooltip.appendChild(tooltipText);
                        highlightTooltip.appendChild(actionButton);

                        pageContentEl.appendChild(highlightTooltip);
                    }
                    pageContentEl.style.display = 'block';
                    pageContentEl.style.visibility = 'visible';
                    pageContentEl.style.opacity = '1';
                    
                    // Ensure it's visible
                    console.log('[Luna Composer] Page content display:', pageContentEl.style.display);
                    console.log('[Luna Composer] Page content innerHTML length:', pageContentEl.innerHTML.length);
                    
                    // Initialize auto-save and history
                    setTimeout(() => {
                        initializeLunaComposerAutoSave();
                        loadLunaComposerHistory();
                        initializeCannedPromptsScroll();
                        initializeLunaComposerIntelligentMode();
                        // Initialize heart icon state for current document
                        window.lunaComposerUpdateHeartState();
                    }, 100);
                } else {
                    console.error('[Luna Composer] Page content element not found!');
                }
                
            } catch (error) {
                console.error('[Luna Composer] Error rendering:', error);
                const pageContentEl = document.getElementById('vlPageContent');
                if (pageContentEl) {
                    pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load Luna Composer: ' + error.message + '</p></div>';
                }
            }
        }

        // Fetch data on load - AFTER authentication is verified
        async function initializeDashboard() {
            try {
                console.log('Initializing dashboard with license key:', licenseKey);
                
                // Check if we're on the Omniscient App Observatory page
                if (isOmniscientPage) {
                    
                    // Ensure page content container is visible BEFORE rendering
                    const pageContent = document.getElementById('vlPageContent');
                    if (pageContent) {
                        pageContent.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 10 !important;';
                    }
                    
                    await renderOmniscientAppObservatory();
                    
                    // Additional safeguard after rendering
                    setTimeout(() => {
                        const overlay = document.querySelector('.vl-supercluster-overlay');
                        const header = document.querySelector('.vl-header');
                        const mainMenu = document.querySelector('.vl-main-menu');
                        const rightSidebar = document.querySelector('.vl-right-sidebar');
                        const pageContentEl = document.getElementById('vlPageContent');
                        const rootContainerEl = document.getElementById('vlSuperclusterRoot');
                        
                        
                        if (overlay) {
                            overlay.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                        }
                        if (header) {
                            header.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                        }
                        if (mainMenu) {
                            mainMenu.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                        }
                        if (rightSidebar) {
                            rightSidebar.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                        }
                        if (pageContentEl) {
                            pageContentEl.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 10 !important;';
                        }
                    }, 100);
                    
                    // Continue checking periodically
                    setTimeout(() => {
                        const pageContentEl = document.getElementById('vlPageContent');
                        const rootContainerEl = document.getElementById('vlSuperclusterRoot');
                        if (pageContentEl && (pageContentEl.style.display === 'none' || window.getComputedStyle(pageContentEl).display === 'none')) {
                            console.warn('[Omniscient] Page content was hidden, restoring');
                            pageContentEl.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 10 !important;';
                        }
                    }, 500);
                    
                    return;
                }
                
                // Check if we're on a shared Luna Composer page
                if (isSharedComposePage && sharedDocumentId) {
                    await renderSharedLunaComposer(sharedDocumentId);
                    return;
                }
                
                // Check if we're on the Luna Composer page
                if (isLunaComposePage) {
                    await renderLunaComposer();
                    return;
                }
                
                // Show Supercluster root and hide page content (default state)
                // Only do this if NOT on Omniscient page
                if (!isOmniscientPage) {
                const rootContainer = document.getElementById('vlSuperclusterRoot');
                const pageContent = document.getElementById('vlPageContent');
                if (rootContainer) {
                    rootContainer.style.display = 'block';
                }
                if (pageContent) {
                    pageContent.style.display = 'none';
                    }
                }
                
                // Check for category page URL first
                if (checkUrlForCategoryPage()) {
                    // Category page is being rendered, exit early
                    return;
                }
                
                // Check for stream data page URL - if found, render that instead of dashboard
                if (checkUrlForStreamDataPage()) {
                    // Stream data page is being rendered, exit early
                    return;
                }
                
                // Update license key display immediately
                updateLicenseKeyDisplay();
                
                // Fetch constellation data for this client's license
                const data = await fetchConstellationData();
            console.log('Constellation data loaded:', data);
            constellationData = data;
            updateVerificationPanel(data, dataFetchError);
                
            if (data && data.clients && data.clients.length > 0) {
                    // Use the client data that matches the license (should be first/only one after filtering)
                    const clientData = data.clients[0];
                    console.log('Updating galaxy with client data:', clientData);
                    // Only update galaxy data if it's initialized (three.js scene is ready)
                    if (typeof galaxyData !== 'undefined' && galaxyData && Array.isArray(galaxyData)) {
                    updateGalaxyDataWithRealData(clientData);
                    } else {
                        console.warn('[Supercluster] galaxyData not yet initialized, will update when scene is ready');
                    }
                }
                    
                // Load supercluster summary and recent activity (always call these, even if no client data)
                    await updateSuperclusterSummary();
                    await loadRecentActivity();
                
            // Refresh client name with new data
            await refreshClientName();
                
                // Update license key display again after data is loaded
                updateLicenseKeyDisplay();
                
            } catch (error) {
                console.error('Failed to initialize dashboard:', error);
                dataFetchError = error.message;
            // Still try to refresh client name in case we have cached data
            await refreshClientName();
                // Still try to load widgets even if there's an error
                try {
                    await updateSuperclusterSummary();
                    await loadRecentActivity();
                } catch (widgetError) {
                    console.error('Failed to load widgets:', widgetError);
                }
                updateLicenseKeyDisplay();
            }
        }
        
        // Initialize dashboard after authentication (skip for shared documents)
        if (!isSharedComposePage) {
        initializeDashboard().then(() => {
            // Initialize VL Overlay after dashboard is ready
            initializeVLOverlay();
        }).catch(err => {
            console.error('Dashboard initialization failed:', err);
            // Still try to initialize overlay even if dashboard fails
            initializeVLOverlay();
        });
        }

        // Set up periodic data refresh (every 5 minutes) - only for authenticated users
        if (!isSharedComposePage) {
        setInterval(async () => {
            console.log('Refreshing constellation data...');
            const data = await fetchConstellationData();
            constellationData = data;
            updateVerificationPanel(data, dataFetchError);
            if (data && data.clients && data.clients.length > 0) {
                    // Only update galaxy data if it's initialized (three.js scene is ready)
                    if (typeof galaxyData !== 'undefined' && galaxyData && Array.isArray(galaxyData) && galaxyData.length > 0) {
                updateGalaxyDataWithRealData(data.clients[0]);
                    } else {
                        console.warn('[Supercluster] galaxyData not yet initialized, skipping update');
                    }
            }
            // Refresh client name with new data
            await refreshClientName();
        }, 5 * 60 * 1000); // 5 minutes
        }

        const rootContainer = document.getElementById("vlSuperclusterRoot") || document.body;
        const htmlElement = document.documentElement;
        const bodyElement = document.body;
        const scrollLockClass = "vl-supercluster-scroll-lock";



        function createSoftParticleTexture(size = 256) {
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext("2d");
            const half = size / 2;
            const gradient = context.createRadialGradient(half, half, 0, half, half, half);
            gradient.addColorStop(0, "rgba(255, 255, 255, 1)");
            gradient.addColorStop(0.35, "rgba(255, 255, 255, 0.75)");
            gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        function createNebulaTexture(size = 512) {
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext("2d");
            context.clearRect(0, 0, size, size);
            const center = size / 2;
            
            // Your brand colors
            const brandColors = ['#920101', '#8D8C00', '#974C00'];
            const selectedColor = brandColors[Math.floor(Math.random() * brandColors.length)];
            
            // Convert hex to RGB for opacity variations
            const hex = selectedColor.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);

            const baseGradient = context.createRadialGradient(center, center, size * 0.1, center, center, center);
            baseGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.75)`);
            baseGradient.addColorStop(0.35, `rgba(${r}, ${g}, ${b}, 0.55)`);
            baseGradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.32)`);
            baseGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
            context.fillStyle = baseGradient;
            context.fillRect(0, 0, size, size);

            const shardCount = 8 + Math.floor(Math.random() * 6);
            for (let i = 0; i < shardCount; i++) {
                const shardX = center + (Math.random() - 0.5) * size * 0.55;
                const shardY = center + (Math.random() - 0.5) * size * 0.35;
                const shardRadius = size * (0.08 + Math.random() * 0.14);
                const shardGradient = context.createRadialGradient(
                    shardX,
                    shardY,
                    shardRadius * 0.2,
                    shardX,
                    shardY,
                    shardRadius
                );
                shardGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.65)`);
                shardGradient.addColorStop(0.55, `rgba(${r}, ${g}, ${b}, 0.35)`);
                shardGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
                context.fillStyle = shardGradient;
                context.beginPath();
                context.arc(shardX, shardY, shardRadius, 0, Math.PI * 2);
                context.fill();
            }

            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        // Create dust-like galaxy cloud texture
        function createGalaxyCloudTexture(size = 512, baseColor, uniqueColor) {
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext("2d");
            context.clearRect(0, 0, size, size);
            const center = size / 2;
            
            // Convert colors to RGB
            const baseR = Math.floor(baseColor.r * 255);
            const baseG = Math.floor(baseColor.g * 255);
            const baseB = Math.floor(baseColor.b * 255);
            
            const uniqueR = Math.floor(uniqueColor.r * 255);
            const uniqueG = Math.floor(uniqueColor.g * 255);
            const uniqueB = Math.floor(uniqueColor.b * 255);
            
            // Create multiple overlapping dust clouds
            const cloudCount = 12 + Math.floor(Math.random() * 8);
            for (let i = 0; i < cloudCount; i++) {
                const cloudX = center + (Math.random() - 0.5) * size * 0.7;
                const cloudY = center + (Math.random() - 0.5) * size * 0.7;
                const cloudRadius = size * (0.15 + Math.random() * 0.25);
                
                // Mix base and unique colors for each cloud
                const mixFactor = Math.random();
                const r = Math.floor(baseR * (1 - mixFactor) + uniqueR * mixFactor);
                const g = Math.floor(baseG * (1 - mixFactor) + uniqueG * mixFactor);
                const b = Math.floor(baseB * (1 - mixFactor) + uniqueB * mixFactor);
                
                // Create dust-like gradient with noise
                const cloudGradient = context.createRadialGradient(
                    cloudX,
                    cloudY,
                    cloudRadius * 0.1,
                    cloudX,
                    cloudY,
                    cloudRadius
                );
                cloudGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${0.15 + Math.random() * 0.1})`);
                cloudGradient.addColorStop(0.3, `rgba(${r}, ${g}, ${b}, ${0.08 + Math.random() * 0.08})`);
                cloudGradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, ${0.04 + Math.random() * 0.04})`);
                cloudGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
                
                context.fillStyle = cloudGradient;
                context.beginPath();
                context.arc(cloudX, cloudY, cloudRadius, 0, Math.PI * 2);
                context.fill();
                
                // Add finer dust particles
                const dustCount = 20 + Math.floor(Math.random() * 15);
                for (let j = 0; j < dustCount; j++) {
                    const dustX = cloudX + (Math.random() - 0.5) * cloudRadius * 1.5;
                    const dustY = cloudY + (Math.random() - 0.5) * cloudRadius * 1.5;
                    const dustRadius = cloudRadius * (0.05 + Math.random() * 0.15);
                    const dustAlpha = 0.02 + Math.random() * 0.06;
                    
                    const dustGradient = context.createRadialGradient(
                        dustX,
                        dustY,
                        0,
                        dustX,
                        dustY,
                        dustRadius
                    );
                    dustGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${dustAlpha})`);
                    dustGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
                    
                    context.fillStyle = dustGradient;
                    context.beginPath();
                    context.arc(dustX, dustY, dustRadius, 0, Math.PI * 2);
                    context.fill();
                }
            }
            
            // Add subtle noise for dust texture
            const imageData = context.getImageData(0, 0, size, size);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    const noise = (Math.random() - 0.5) * 0.1;
                    data[i] = Math.max(0, Math.min(255, data[i] + noise * 255));
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise * 255));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise * 255));
                }
            }
            context.putImageData(imageData, 0, 0);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        // Create finer dust particle texture
        function createDustParticleTexture(size = 128) {
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext("2d");
            const half = size / 2;
            const gradient = context.createRadialGradient(half, half, 0, half, half, half);
            gradient.addColorStop(0, "rgba(255, 255, 255, 0.8)");
            gradient.addColorStop(0.4, "rgba(255, 255, 255, 0.4)");
            gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        const baseParticleTexture = createSoftParticleTexture();
        const dustParticleTexture = createDustParticleTexture();

            // Only initialize three.js scene if NOT on Omniscient App Observatory page or Luna Composer page
            let scene, renderer, camera, controls, superclusterGroup;
            
            if (!isOmniscientPage && !isLunaComposePage) {
            scene = new THREE.Scene();
        scene.background = new THREE.Color(0x02040a);
        scene.fog = new THREE.FogExp2(0x040714, 0.00035);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.12;
            rootContainer.insertBefore(renderer.domElement, rootContainer.firstChild || null);

            camera = new THREE.PerspectiveCamera(52, window.innerWidth / window.innerHeight, 0.1, 1500);
        camera.position.set(0, 120, 800); // Start at maximum zoom-out distance

            controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 120;
        controls.maxDistance = 800;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.18;
        controls.enablePan = false;
        
        // Set the target to center on the supercluster (0, 0, 0)
        controls.target.set(0, 0, 0);
        controls.update();

            superclusterGroup = new THREE.Group();
        superclusterGroup.name = 'superclusterGroup';
        scene.add(superclusterGroup);

        const atmosphereShell = new THREE.Mesh(
            new THREE.SphereGeometry(1400, 64, 64),
            new THREE.MeshBasicMaterial({
                color: 0x060b18,
                transparent: true,
                opacity: 0.42,
                side: THREE.BackSide,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
            })
        );
        scene.add(atmosphereShell);

        const nebulaGroup = new THREE.Group();
        superclusterGroup.add(nebulaGroup);
        const nebulaClouds = [];

        function seedNebulaClouds() {
            nebulaGroup.clear();
            nebulaClouds.length = 0;
            const cloudCount = 7 + Math.floor(Math.random() * 3);
            for (let i = 0; i < cloudCount; i++) {
                const nebulaTexture = createNebulaTexture();
                const geometry = new THREE.PlaneGeometry(420 + Math.random() * 260, 280 + Math.random() * 180, 1, 1);
                const material = new THREE.MeshBasicMaterial({
                    map: nebulaTexture,
                    transparent: true,
                    opacity: 0.24 + Math.random() * 0.18,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    depthTest: false,
                    side: THREE.DoubleSide,
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set((Math.random() - 0.5) * 420, (Math.random() - 0.5) * 260, (Math.random() - 0.5) * 420);
                mesh.rotation.set(
                    Math.PI / 2 + (Math.random() - 0.5) * 0.6,
                    (Math.random() - 0.5) * 0.9,
                    (Math.random() - 0.5) * 0.6
                );
                mesh.userData = {
                    baseOpacity: material.opacity,
                    basePosition: mesh.position.clone(),
                    drift: new THREE.Vector3((Math.random() - 0.5) * 26, (Math.random() - 0.5) * 18, (Math.random() - 0.5) * 26),
                    rotationSpeed: 0.00008 + Math.random() * 0.00018,
                    phaseOffset: Math.random() * Math.PI * 2,
                };
                nebulaGroup.add(mesh);
                nebulaClouds.push(mesh);
            }
        }

        seedNebulaClouds();

        // Declare galaxyData globally so it's accessible to updateGalaxyDataWithRealData
        if (typeof galaxyData === 'undefined') {
            var galaxyData = [];
        }
        
        galaxyData = [
            {
                name: "Website Infrastructure & Performance",
                datasetSlugs: ["infrastructure", "themes", "operations"],
                fallbackDescription:
                    "Optimize delivery, resiliency, and user experience with infrastructure telemetry spanning uptime, performance, and observability signals.",
                description: "",
                position: new THREE.Vector3(-220, 60, -140),
                color: "#6fb1ff",
                connections: ["Content Management & Structure", "Analytics & Engagement"],
            },
            {
                name: "Content Management & Structure",
                datasetSlugs: ["content", "structure"],
                fallbackDescription:
                    "Govern editorial pipelines, asset taxonomies, and omnichannel orchestration to keep experiences coherent across platforms.",
                description: "",
                position: new THREE.Vector3(-80, 20, 60),
                color: "#ff9cf0",
                connections: ["Website Infrastructure & Performance", "Search Engine Intelligence", "Marketing & Campaign Data"],
            },
            {
                name: "Search Engine Intelligence",
                datasetSlugs: ["ai", "search", "integrations"],
                fallbackDescription:
                    "Harvest crawl signals, SERP movement, and algorithmic shifts to ensure content is discoverable and performant.",
                description: "",
                position: new THREE.Vector3(40, 140, -60),
                color: "#83f3ff",
                connections: ["Content Management & Structure", "Analytics & Engagement", "Competitive & Market Data"],
            },
            {
                name: "Analytics & Engagement",
                datasetSlugs: ["sessions", "analytics", "engagement"],
                fallbackDescription:
                    "Synthesize behavioral analytics, funnel friction, and feedback loops to illuminate experience optimization opportunities.",
                description: "",
                position: new THREE.Vector3(160, 40, 120),
                color: "#ffe699",
                connections: ["Website Infrastructure & Performance", "Search Engine Intelligence", "Marketing & Campaign Data", "User & Identity Layer"],
            },
            {
                name: "Marketing & Campaign Data",
                datasetSlugs: ["integrations", "marketing", "campaigns"],
                fallbackDescription:
                    "Unify campaign performance, attribution modeling, and creative intelligence to amplify revenue-driving initiatives.",
                description: "",
                position: new THREE.Vector3(260, -20, -80),
                color: "#d9a6ff",
                connections: ["Content Management & Structure", "Analytics & Engagement", "E-Commerce & Conversion Data"],
            },
            {
                name: "E-Commerce & Conversion Data",
                datasetSlugs: ["plugins", "commerce", "ecommerce"],
                fallbackDescription:
                    "Map product analytics, merchandising flows, and conversion health to reveal revenue acceleration pathways.",
                description: "",
                position: new THREE.Vector3(-40, -120, -40),
                color: "#ff6b6b",
                connections: ["Marketing & Campaign Data", "User & Identity Layer", "Security & Compliance Data"],
            },
            {
                name: "Security & Compliance Data",
                datasetSlugs: ["security", "compliance"],
                fallbackDescription:
                    "Monitor threat detection, governance policies, and regulatory controls to keep the data supply chain secure.",
                description: "",
                position: new THREE.Vector3(-200, -40, 150),
                color: "#9dffb0",
                connections: ["CloudOps & Infrastructure Metrics", "E-Commerce & Conversion Data"],
            },
            {
                name: "CloudOps & Infrastructure Metrics",
                datasetSlugs: ["themes", "infrastructure", "cloudops"],
                fallbackDescription:
                    "Observe deployment velocity, cost efficiency, and platform reliability to ensure modern operations excellence.",
                description: "",
                position: new THREE.Vector3(100, -180, 60),
                color: "#ffc7a5",
                connections: ["Security & Compliance Data", "Website Infrastructure & Performance"],
            },
            {
                name: "User & Identity Layer",
                datasetSlugs: ["identity", "users"],
                fallbackDescription:
                    "Understand identity graphs, access journeys, and consent preferences to personalize experiences responsibly.",
                description: "",
                position: new THREE.Vector3(-280, 160, 60),
                color: "#7f9bff",
                connections: ["Analytics & Engagement", "E-Commerce & Conversion Data", "Competitive & Market Data"],
            },
            {
                name: "Competitive & Market Data",
                datasetSlugs: ["users", "market", "competitive"],
                fallbackDescription:
                    "Track competitive shifts, market momentum, and whitespace detection to guide strategic positioning.",
                description: "",
                position: new THREE.Vector3(60, -40, 220),
                color: "#9bffe7",
                connections: ["Search Engine Intelligence", "User & Identity Layer"],
            },
        ];

        galaxyData.forEach((entry) => {
            entry.slug = entry.datasetSlugs[0];
            entry.description = entry.fallbackDescription;
            entry.metrics = null;
        });

        const galaxyGroups = new Map();

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const tempWorldPosition = new THREE.Vector3();
        const projectedPosition = new THREE.Vector3();
        const cameraDirection = new THREE.Vector3();
        const panRight = new THREE.Vector3();
        const zoomOffset = new THREE.Vector3();

        // Only create labels container if NOT on Luna Composer page
        let labelsContainer = null;
        if (!isLunaComposePage) {
            labelsContainer = document.createElement("div");
        labelsContainer.className = "vl-supercluster-labels";
            rootContainer.appendChild(labelsContainer);
        }

        function createLabel(name) {
            const el = document.createElement("div");
            el.className = "floating-label";
            el.textContent = name;
            
            // Custom styling for galaxy labels
            el.style.position = "absolute"; // Required for backdropFilter
            el.style.color = "#fff4e7"; // White text
            el.style.fontSize = "14px";
            el.style.fontWeight = "600";
            el.style.letterSpacing = "0";
            el.style.textTransform = "capitalize";
            el.style.textShadow = "0 0 10px rgba(0,0,0, 0.8)"; // Blue glow
            el.style.background = "rgba(0,0,0, 0.8)"; // Dark background
            el.style.padding = "8px 12px";
            el.style.borderRadius = "50px";
            el.style.backdropFilter = "blur(8px)"; // Standard
            el.style.webkitBackdropFilter = "blur(8px)"; // Safari support
            el.style.isolation = "isolate"; // Create stacking context
            el.style.willChange = "transform"; // Optimize rendering
            
            if (labelsContainer) {
            labelsContainer.appendChild(el);
            }
            return el;
        }

        function createGalaxy({ name, position, color }) {
            const group = new THREE.Group();
            group.position.copy(position);

            const baseColor = new THREE.Color(color);
            const highlightColor = baseColor.clone().lerp(new THREE.Color(0xffffff), 0.35);
            const coreColor = baseColor.clone().lerp(new THREE.Color(0xffffcc), 0.4);

            // Central core/bulge - brighter and more defined
            const coreGeometry = new THREE.SphereGeometry(8.5, 64, 64);
            const coreMaterial = new THREE.MeshPhongMaterial({
                color: coreColor,
                emissive: baseColor.clone().multiplyScalar(0.75),
                shininess: 180,
                specular: 0xffffff,
            });
            coreMaterial.emissiveIntensity = 1.4;
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            group.add(core);

            // Extended halo around core - more subtle glow
            const haloGeometry = new THREE.SphereGeometry(32, 64, 64);
            const haloMaterial = new THREE.MeshBasicMaterial({
                color: highlightColor,
                transparent: true,
                opacity: 0.18,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false,
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            group.add(halo);

            // Additional subtle glow layers
            const halo2Geometry = new THREE.SphereGeometry(40, 64, 64);
            const halo2Material = new THREE.MeshBasicMaterial({
                color: highlightColor,
                transparent: true,
                opacity: 0.12,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false,
            });
            const halo2 = new THREE.Mesh(halo2Geometry, halo2Material);
            group.add(halo2);
            
            const halo3Geometry = new THREE.SphereGeometry(50, 64, 64);
            const halo3Material = new THREE.MeshBasicMaterial({
                color: baseColor,
                transparent: true,
                opacity: 0.08,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false,
            });
            const halo3 = new THREE.Mesh(halo3Geometry, halo3Material);
            group.add(halo3);

            // Replace oval discs with prominent galaxy clouds - unique colors per galaxy
            const uniqueColorHue = Math.random() * 0.3 + 0.5; // Vary hue slightly
            const uniqueColor = new THREE.Color().setHSL(uniqueColorHue, 0.4 + Math.random() * 0.3, 0.5 + Math.random() * 0.3);
            const cloudTexture1 = createGalaxyCloudTexture(512, baseColor, uniqueColor);
            
            // Main galactic cloud - more prominent and dust-like
            const cloudGeometry1 = new THREE.PlaneGeometry(90, 90, 1, 1);
            const cloudMaterial1 = new THREE.MeshBasicMaterial({
                map: cloudTexture1,
                transparent: true,
                opacity: 0.35,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false,
            });
            const cloud1 = new THREE.Mesh(cloudGeometry1, cloudMaterial1);
            cloud1.rotation.x = Math.PI / 2;
            cloud1.rotation.z = Math.random() * Math.PI;
            cloud1.rotation.y = Math.random() * Math.PI * 0.3;
            group.add(cloud1);
            
            // Secondary cloud layer for depth
            const cloudTexture2 = createGalaxyCloudTexture(512, baseColor, uniqueColor);
            const cloudGeometry2 = new THREE.PlaneGeometry(110, 110, 1, 1);
            const cloudMaterial2 = new THREE.MeshBasicMaterial({
                map: cloudTexture2,
                transparent: true,
                opacity: 0.22,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false,
            });
            const cloud2 = new THREE.Mesh(cloudGeometry2, cloudMaterial2);
            cloud2.rotation.x = Math.PI / 2.1;
            cloud2.rotation.z = Math.random() * Math.PI;
            cloud2.rotation.y = Math.random() * Math.PI * 0.3;
            group.add(cloud2);
            
            // Outer cloud ring
            const cloudTexture3 = createGalaxyCloudTexture(512, baseColor, uniqueColor);
            const cloudGeometry3 = new THREE.PlaneGeometry(130, 130, 1, 1);
            const cloudMaterial3 = new THREE.MeshBasicMaterial({
                map: cloudTexture3,
                transparent: true,
                opacity: 0.18,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false,
            });
            const outerCloud = new THREE.Mesh(cloudGeometry3, cloudMaterial3);
            outerCloud.rotation.x = Math.PI / 2.15 + (Math.random() - 0.5) * 0.2;
            outerCloud.rotation.z = Math.random() * Math.PI;
            group.add(outerCloud);

            // Create realistic spiral arms - more defined and galaxy-like
            const armCount = 2 + Math.floor(Math.random() * 2); // 2-3 arms like real galaxies
            const pointsPerArm = 200;
            const swirlPositions = new Float32Array(armCount * pointsPerArm * 3);
            const swirlColors = new Float32Array(armCount * pointsPerArm * 3);
            let pointer = 0;
            let colorPointer = 0;
            
            for (let arm = 0; arm < armCount; arm++) {
                const armOffset = (Math.PI * 2 * arm) / armCount;
                const armTightness = 0.12 + Math.random() * 0.08; // Spiral tightness
                
                for (let i = 0; i < pointsPerArm; i++) {
                    const t = i / pointsPerArm;
                    // Logarithmic spiral for more realistic appearance
                    const angle = t * Math.PI * 4.2 + armOffset + Math.log(1 + t * 9) * armTightness;
                    const radius = 12 + t * 110 + Math.sin(t * Math.PI * 3) * 8; // More variation
                    const jitter = (1 - t) * 4; // Less jitter for cleaner arms
                    
                    const x = Math.cos(angle) * radius + (Math.random() - 0.5) * jitter;
                    const y = (Math.random() - 0.5) * (4 + t * 18); // Flatter disc
                    const z = Math.sin(angle) * radius + (Math.random() - 0.5) * jitter;
                    
                    swirlPositions[pointer++] = x;
                    swirlPositions[pointer++] = y;
                    swirlPositions[pointer++] = z;
                    
                    // Color gradient along arms (brighter near core)
                    const brightness = 0.6 + (1 - t) * 0.4;
                    const armColor = highlightColor.clone().multiplyScalar(brightness);
                    swirlColors[colorPointer++] = armColor.r;
                    swirlColors[colorPointer++] = armColor.g;
                    swirlColors[colorPointer++] = armColor.b;
                }
            }
            
            const swirlGeometry = new THREE.BufferGeometry();
            swirlGeometry.setAttribute("position", new THREE.BufferAttribute(swirlPositions, 3));
            swirlGeometry.setAttribute("color", new THREE.BufferAttribute(swirlColors, 3));
            
            const swirlMaterial = new THREE.PointsMaterial({
                map: baseParticleTexture,
                color: highlightColor,
                vertexColors: true,
                size: 12 + Math.random() * 4,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.65,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                depthTest: false,
                alphaTest: 0.01,
            });
            
            const swirl = new THREE.Points(swirlGeometry, swirlMaterial);
            swirl.rotation.x = Math.PI / 2.35 + (Math.random() - 0.5) * 0.12;
            swirl.userData = {
                spinSpeed: 0.00018 + Math.random() * 0.00012,
                baseOpacity: swirlMaterial.opacity,
                wobbleStrength: 0.06 + Math.random() * 0.04,
            };
            group.add(swirl);

            // More stars with varying sizes
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 1400; // Increased from 720
            const positions = new Float32Array(starCount * 3);
            const starSizes = new Float32Array(starCount);
            const starColors = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount; i++) {
                const radius = 20 + Math.random() * 130;
                const theta = Math.random() * Math.PI * 2;
                const cosPhi = Math.random() * 2 - 1;
                const phi = Math.acos(cosPhi);
                const wobble = Math.pow(Math.random(), 2.4);
                positions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
                positions[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * radius * (0.35 + Math.random() * 0.9);
                positions[i * 3 + 2] = Math.cos(phi) * radius;
                if (Math.random() > 0.6) {
                    positions[i * 3 + 1] *= 0.45 + wobble * 0.55;
                }
                
                // Varying star sizes
                starSizes[i] = 3 + Math.random() * 8 + Math.pow(Math.random(), 3) * 5;
                
                // Varying star colors (slightly tinted)
                const starBrightness = 0.7 + Math.random() * 0.3;
                const starColor = highlightColor.clone().lerp(new THREE.Color(0xffffff), 0.3 + Math.random() * 0.2);
                starColor.multiplyScalar(starBrightness);
                starColors[i * 3] = starColor.r;
                starColors[i * 3 + 1] = starColor.g;
                starColors[i * 3 + 2] = starColor.b;
            }

            starGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute("size", new THREE.BufferAttribute(starSizes, 1));
            starGeometry.setAttribute("color", new THREE.BufferAttribute(starColors, 3));

            const starMaterial = new THREE.PointsMaterial({
                map: baseParticleTexture,
                color: highlightColor.clone().lerp(new THREE.Color(0xffffff), 0.25),
                vertexColors: true,
                size: 6.5,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.65,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending,
            });
            const stars = new THREE.Points(starGeometry, starMaterial);
            stars.userData = { type: "galaxy", name, baseCount: starCount };
            group.add(stars);
            
            // Add finer dust-like particles
            const dustGeometry = new THREE.BufferGeometry();
            const dustCount = 800;
            const dustPositions = new Float32Array(dustCount * 3);
            const dustSizes = new Float32Array(dustCount);
            const dustColors = new Float32Array(dustCount * 3);
            
            for (let i = 0; i < dustCount; i++) {
                const radius = 15 + Math.random() * 100;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                dustPositions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
                dustPositions[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * radius * (0.3 + Math.random() * 0.7);
                dustPositions[i * 3 + 2] = Math.cos(phi) * radius;
                
                // Smaller dust particles
                dustSizes[i] = 1.5 + Math.random() * 3;
                
                // Dust particles with unique color tint
                const dustColor = baseColor.clone().lerp(uniqueColor, 0.3 + Math.random() * 0.4);
                dustColor.multiplyScalar(0.4 + Math.random() * 0.3);
                dustColors[i * 3] = dustColor.r;
                dustColors[i * 3 + 1] = dustColor.g;
                dustColors[i * 3 + 2] = dustColor.b;
            }
            
            dustGeometry.setAttribute("position", new THREE.BufferAttribute(dustPositions, 3));
            dustGeometry.setAttribute("size", new THREE.BufferAttribute(dustSizes, 1));
            dustGeometry.setAttribute("color", new THREE.BufferAttribute(dustColors, 3));
            
            const dustMaterial = new THREE.PointsMaterial({
                map: dustParticleTexture,
                vertexColors: true,
                size: 2.5,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.35,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending,
            });
            const dust = new THREE.Points(dustGeometry, dustMaterial);
            dust.userData = { spinSpeed: 0.00008 + Math.random() * 0.00006 };
            group.add(dust);

            const sparkGeometry = new THREE.BufferGeometry();
            const sparkCount = 160;
            const sparkPositions = new Float32Array(sparkCount * 3);
            for (let i = 0; i < sparkCount; i++) {
                const radius = 16 + Math.random() * 42;
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 14;
                sparkPositions[i * 3] = Math.cos(angle) * radius;
                sparkPositions[i * 3 + 1] = height;
                sparkPositions[i * 3 + 2] = Math.sin(angle) * radius;
            }
            sparkGeometry.setAttribute("position", new THREE.BufferAttribute(sparkPositions, 3));
            const sparkMaterial = new THREE.PointsMaterial({
                map: baseParticleTexture,
                color: highlightColor.clone().lerp(new THREE.Color(0xffffff), 0.5),
                size: 10,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.42,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending,
            });
            const sparkLayer = new THREE.Points(sparkGeometry, sparkMaterial);
            sparkLayer.rotation.x = Math.PI / 2;
            sparkLayer.userData = { spinSpeed: 0.00035 + Math.random() * 0.0002 };
            group.add(sparkLayer);

            // More realistic lighting - softer point light
            const pointLight = new THREE.PointLight(highlightColor, 2.2, 600, 2.2);
            pointLight.position.set(0, 0, 0);
            group.add(pointLight);
            
            // Additional subtle rim light
            const rimLight = new THREE.PointLight(baseColor, 0.8, 400, 1.8);
            rimLight.position.set(0, 0, 0);
            group.add(rimLight);

            const label = createLabel(name);
            label.dataset.target = name;

            galaxyGroups.set(name, {
                name,
                group,
                core,
                halo,
                halo2,
                halo3,
                stars,
                dust,
                swirl,
                sparkLayer,
                cloud1,
                cloud2,
                outerCloud,
                orbit: outerCloud, // Use outerCloud instead of orbit
                label,
                pointLight,
                rimLight,
                baseColor: baseColor.clone(),
                color: highlightColor.clone(),
                uniqueColor: uniqueColor.clone(),
                dataset: null,
                baseStarSize: starMaterial.size,
            });
            superclusterGroup.add(group);
        }

        galaxyData.forEach(createGalaxy);
        
        // After galaxyData is initialized, update it with real data if available
        if (constellationData && constellationData.clients && constellationData.clients.length > 0) {
            const clientData = constellationData.clients[0];
            console.log('[Supercluster] Updating galaxy data with real data after initialization');
            updateGalaxyDataWithRealData(clientData);
        }

        const ambientLight = new THREE.AmbientLight(0x5f6f9f, 0.48);
        scene.add(ambientLight);

        const rimLight = new THREE.DirectionalLight(0x9fd6ff, 0.75);
        rimLight.position.set(120, 260, 180);
        scene.add(rimLight);

        const warmLight = new THREE.DirectionalLight(0xffbf80, 0.58);
        warmLight.position.set(-220, -160, -180);
        scene.add(warmLight);

        const coolFillLight = new THREE.DirectionalLight(0x3b58ff, 0.32);
        coolFillLight.position.set(-140, 120, 260);
        scene.add(coolFillLight);

        // More dense background stars but very subtle
        const starFieldGeometry = new THREE.BufferGeometry();
        const starFieldCount = 6800; // Increased from 4200
        const starFieldPositions = new Float32Array(starFieldCount * 3);
        const starFieldColors = new Float32Array(starFieldCount * 3);
        const starFieldSizes = new Float32Array(starFieldCount);

        const color = new THREE.Color();
        for (let i = 0; i < starFieldCount; i++) {
            const radius = 920 * Math.cbrt(Math.random());
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            starFieldPositions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
            starFieldPositions[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * radius;
            starFieldPositions[i * 3 + 2] = Math.cos(phi) * radius;

            // Subtle colors with varying brightness
            const hue = 0.55 + Math.random() * 0.12;
            const brightness = 0.4 + Math.random() * 0.3; // More subtle
            color.setHSL(hue, 0.5, brightness);
            starFieldColors[i * 3] = color.r;
            starFieldColors[i * 3 + 1] = color.g;
            starFieldColors[i * 3 + 2] = color.b;
            
            // Varying sizes
            starFieldSizes[i] = 1.5 + Math.random() * 3;
        }

        starFieldGeometry.setAttribute("position", new THREE.BufferAttribute(starFieldPositions, 3));
        starFieldGeometry.setAttribute("color", new THREE.BufferAttribute(starFieldColors, 3));
        starFieldGeometry.setAttribute("size", new THREE.BufferAttribute(starFieldSizes, 1));

        const starFieldMaterial = new THREE.PointsMaterial({
            map: baseParticleTexture,
            size: 2.8,
            vertexColors: true,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.35, // More subtle - reduced from 0.62
            depthWrite: false,
            depthTest: false,
            blending: THREE.AdditiveBlending,
        });

        const starField = new THREE.Points(starFieldGeometry, starFieldMaterial);
        scene.add(starField);

        // Far background stars - more dense but very subtle
        const farStarFieldGeometry = new THREE.BufferGeometry();
        const farStarFieldCount = 7200; // Increased from 5200
        const farStarFieldPositions = new Float32Array(farStarFieldCount * 3);
        const farStarFieldColors = new Float32Array(farStarFieldCount * 3);
        const farStarFieldSizes = new Float32Array(farStarFieldCount);
        
        for (let i = 0; i < farStarFieldCount; i++) {
            const radius = 1500 * Math.cbrt(Math.random());
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            farStarFieldPositions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
            farStarFieldPositions[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * radius;
            farStarFieldPositions[i * 3 + 2] = Math.cos(phi) * radius;

            // More subtle colors
            const hue = 0.54 + Math.random() * 0.1;
            const brightness = 0.3 + Math.random() * 0.2; // More subtle
            color.setHSL(hue, 0.4, brightness);
            farStarFieldColors[i * 3] = color.r;
            farStarFieldColors[i * 3 + 1] = color.g;
            farStarFieldColors[i * 3 + 2] = color.b;
            
            // Varying sizes
            farStarFieldSizes[i] = 2 + Math.random() * 4;
        }
        farStarFieldGeometry.setAttribute("position", new THREE.BufferAttribute(farStarFieldPositions, 3));
        farStarFieldGeometry.setAttribute("color", new THREE.BufferAttribute(farStarFieldColors, 3));
        farStarFieldGeometry.setAttribute("size", new THREE.BufferAttribute(farStarFieldSizes, 1));

        const farStarFieldMaterial = new THREE.PointsMaterial({
            map: baseParticleTexture,
            size: 4.5,
            vertexColors: true,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.22, // More subtle - reduced from 0.38
            depthWrite: false,
            depthTest: false,
            blending: THREE.AdditiveBlending,
        });

        const farStarField = new THREE.Points(farStarFieldGeometry, farStarFieldMaterial);
        scene.add(farStarField);

        const connectionBaseColor = new THREE.Color(0x6bc8ff);
        const connectionLines = new THREE.Group();
        superclusterGroup.add(connectionLines);
        
        // Make connectionLines globally accessible
        window.connectionLines = connectionLines;
        const connectionFlowEntries = [];

        const connectionKey = (a, b) => [a, b].sort().join("::");
        const createdConnections = new Set();

        function drawConnections() {
            connectionLines.children.slice().forEach((child) => {
                if (child.geometry) {
                    child.geometry.dispose();
                }
                if (child.material) {
                    child.material.dispose();
                }
            });
            connectionLines.clear();
            connectionFlowEntries.length = 0;
            createdConnections.clear();
            for (const data of galaxyData) {
                const source = galaxyGroups.get(data.name);
                data.connections.forEach((targetName) => {
                    const key = connectionKey(data.name, targetName);
                    if (createdConnections.has(key)) return;

                    const target = galaxyGroups.get(targetName);
                    if (!target) return;

                    const points = [];
                    points.push(source.group.position.clone());
                    const control = source.group.position.clone()
                        .add(target.group.position)
                        .multiplyScalar(0.5)
                        .add(new THREE.Vector3(
                            (Math.random() - 0.5) * 120,
                            (Math.random() - 0.5) * 120,
                            (Math.random() - 0.5) * 120,
                        ));
                    points.push(control);
                    points.push(target.group.position.clone());

                    const curve = new THREE.CatmullRomCurve3(points);
                    // Thinner, more ethereal connection lines
                    const geometry = new THREE.TubeGeometry(curve, 128, 1.2, 16, false);

                    const sourceColor = source?.core?.material?.color?.clone?.() || connectionBaseColor.clone();
                    const targetColor = galaxyGroups.get(targetName)?.core?.material?.color?.clone?.() || connectionBaseColor.clone();
                    const blendedColor = sourceColor.lerp(targetColor, 0.5);

                    const baseOpacity = 0.28 + Math.random() * 0.08;
                    const flowMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            uColor: { value: blendedColor.clone() },
                            uOpacity: { value: baseOpacity },
                            uTime: { value: Math.random() },
                            uHighlight: { value: 0 },
                            uGlowIntensity: { value: 1.2 },
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            varying vec3 vPosition;
                            varying vec3 vNormal;
                            void main() {
                                vUv = uv;
                                vPosition = position;
                                vNormal = normal;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform vec3 uColor;
                            uniform float uOpacity;
                            uniform float uHighlight;
                            uniform float uTime;
                            uniform float uGlowIntensity;
                            varying vec2 vUv;
                            varying vec3 vPosition;
                            varying vec3 vNormal;

                            void main() {
                                // Ethereal flow effect
                                float flow = fract(vUv.x * 1.5 - uTime * 0.8);
                                float head = smoothstep(0.0, 0.3, flow) * smoothstep(1.0, 0.7, flow);
                                
                                // Smooth tapering at ends
                                float taper = smoothstep(0.0, 0.15, vUv.x) * smoothstep(1.0, 0.85, vUv.x);
                                
                                // Pulsing glow effect
                                float pulse = sin(uTime * 2.0 + vUv.x * 3.14159) * 0.5 + 0.5;
                                pulse = smoothstep(0.3, 0.7, pulse);
                                
                                // Radial glow from center of tube
                                float radialGlow = 1.0 - abs(vUv.y - 0.5) * 2.0;
                                radialGlow = pow(radialGlow, 1.5);
                                
                                // Highlight effect
                                float highlight = uHighlight;
                                
                                // Base color with taper
                                vec3 baseColor = mix(uColor * (0.4 + 0.6 * taper), vec3(1.0), highlight * 0.4);
                                
                                // Ethereal glow - more wispy and fluid
                                vec3 glowColor = uColor * (0.5 + 0.5 * pulse) * (0.6 + 0.4 * taper) * radialGlow * uGlowIntensity;
                                
                                // Add flowing particles effect
                                float particles = smoothstep(0.0, 0.2, flow) * smoothstep(1.0, 0.8, flow);
                                glowColor += uColor * particles * 0.6;
                                
                                // Combine colors
                                vec3 color = baseColor + glowColor * (1.0 + highlight * 0.8);
                                
                                // Alpha with smooth fade
                                float alpha = uOpacity * (0.4 + 0.6 * taper) * (0.7 + 0.3 * radialGlow) * (1.0 + highlight * 0.6 + head * 0.4);
                                
                                gl_FragColor = vec4(color, alpha);
                            }
                        `,
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                        side: THREE.DoubleSide,
                    });

                    const mesh = new THREE.Mesh(geometry, flowMaterial);
                    mesh.userData = {
                        start: data.name,
                        end: targetName,
                        baseColor: blendedColor.clone(),
                        baseOpacity,
                        targetOpacity: baseOpacity,
                        flowSpeed: 0.1 + Math.random() * 0.18,
                    };
                    connectionLines.add(mesh);
                    connectionFlowEntries.push(mesh);

                    createdConnections.add(key);
                });
            }
        }

        drawConnections();

        const infoCard = document.getElementById("infoCard");
        const infoMetricsList = document.getElementById("infoMetrics");
        const defaultSubtitle = "Select a Stream Category";
        const defaultIntroText =
            "Explore the connective tissue of Visible Light AI's intelligence streams. Click any galaxy to learn how each stream powers the constellation of insights.";

        function appendMetric(list, title, detail) {
            if (!list) return;
            const item = document.createElement("li");
            const heading = document.createElement("strong");
            heading.textContent = title;
            const value = document.createElement("span");
            value.textContent = detail;
            item.append(heading, value);
            list.appendChild(item);
        }

        function updateInfoCard(data) {
            if (!infoCard) {
                return;
            }

            if (!data) {
                infoCard.querySelector("h1").textContent = "Visible Light AI Supercluster";
                infoCard.querySelector("h2").textContent = defaultSubtitle;
                infoCard.querySelector("p").textContent = defaultIntroText;
                if (infoMetricsList) {
                    infoMetricsList.innerHTML = "";
                    if (constellationData) {
                        appendMetric(infoMetricsList, "Status", `Connected to VL Hub - ${constellationData.total_clients} clients`);
                        appendMetric(infoMetricsList, "License", licenseKey ? `${licenseKey.substring(0, 8)}...` : "No license key");
                    } else if (dataFetchError) {
                        appendMetric(infoMetricsList, "Status", `Connection failed: ${dataFetchError}`);
                        appendMetric(infoMetricsList, "Retry", "Refreshing in 30 seconds...");
                    } else {
                        appendMetric(infoMetricsList, "Status", "Connecting to VL Hub...");
                    }
                }
                infoCard.classList.remove("visible");
                requestAnimationFrame(() => infoCard.classList.add("visible"));
                return;
            }

            infoCard.querySelector("h1").textContent = data.name;
            const subtitleParts = ["Stream Category"];
            if (data.metrics?.categoryName) {
                subtitleParts.unshift(data.metrics.categoryName);
            }
            if (data.metrics?.clientName) {
                subtitleParts.push(data.metrics.clientName);
            }
            infoCard.querySelector("h2").textContent = subtitleParts.join(" • ");
            infoCard.querySelector("p").textContent = data.description;

            if (infoMetricsList) {
                infoMetricsList.innerHTML = "";
                if (data.metrics) {
                    appendMetric(
                        infoMetricsList,
                        "Signals",
                        data.metrics.nodesCount != null ? `${data.metrics.nodesCount} active` : "Awaiting telemetry"
                    );
                    const topNodes = Array.isArray(data.metrics.topNodes) ? data.metrics.topNodes : [];
                    topNodes.slice(0, 4).forEach((node) => {
                        appendMetric(infoMetricsList, node.label, node.detail);
                    });
                    if (!topNodes.length) {
                        appendMetric(infoMetricsList, "Insight", "Awaiting telemetry from VL Hub.");
                    }
                } else {
                    appendMetric(infoMetricsList, "Insight", "Awaiting telemetry from VL Hub.");
                }
            }

            infoCard.classList.add("visible");
        }

        let hoveredGalaxy = null;
        let activeGalaxy = null;

        function setGalaxyGlow(name, intensity) {
            const entry = galaxyGroups.get(name);
            if (!entry) return;
            entry.core.material.emissiveIntensity = 1.4 + intensity * 0.8;
            
            // Animate multiple halo layers
            entry.halo.material.opacity = 0.18 + intensity * 0.25;
            if (entry.halo2) {
                entry.halo2.material.opacity = 0.12 + intensity * 0.18;
            }
            if (entry.halo3) {
                entry.halo3.material.opacity = 0.08 + intensity * 0.12;
            }
            
            const baseSize = entry.baseStarSize ?? entry.stars.material.size ?? 6.5;
            entry.stars.material.size = baseSize + intensity * 4.5;
            
            if (entry.swirl?.material) {
                const baseOpacity = entry.swirl.userData?.baseOpacity ?? entry.swirl.material.opacity ?? 0.5;
                entry.swirl.material.opacity = baseOpacity + intensity * 0.3;
                entry.swirl.material.needsUpdate = true;
            }
            if (entry.sparkLayer?.material) {
                entry.sparkLayer.material.opacity = 0.32 + intensity * 0.4;
                entry.sparkLayer.material.needsUpdate = true;
            }
            if (entry.dust?.material) {
                entry.dust.material.opacity = 0.35 + intensity * 0.25;
                entry.dust.material.needsUpdate = true;
            }
            
            // Animate galaxy clouds
            if (entry.cloud1?.material) {
                entry.cloud1.material.opacity = 0.35 + intensity * 0.25;
                entry.cloud1.material.needsUpdate = true;
            }
            if (entry.cloud2?.material) {
                entry.cloud2.material.opacity = 0.22 + intensity * 0.18;
                entry.cloud2.material.needsUpdate = true;
            }
            if (entry.outerCloud?.material) {
                entry.outerCloud.material.opacity = 0.18 + intensity * 0.15;
                entry.outerCloud.material.needsUpdate = true;
            }
            
            if (entry.pointLight) {
                entry.pointLight.intensity = 2.2 + intensity * 1.8;
                entry.pointLight.distance = 600 + intensity * 100;
            }
            if (entry.rimLight) {
                entry.rimLight.intensity = 0.8 + intensity * 0.6;
                entry.rimLight.distance = 400 + intensity * 80;
            }
        }

        function onPointerMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            if (!rect.width || !rect.height) {
                return;
            }
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -(((event.clientY - rect.top) / rect.height) * 2 - 1);
        }

        function onClick() {
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(
                Array.from(galaxyGroups.values()).map((entry) => entry.core),
                false
            );

            if (intersects.length > 0) {
                const name = galaxyData.find((g) => galaxyGroups.get(g.name).core === intersects[0].object)?.name;
                if (name) {
                    if (activeGalaxy && activeGalaxy !== name) {
                        setGalaxyGlow(activeGalaxy, 0);
                    }
                    activeGalaxy = name;
                    setGalaxyGlow(name, 1);
                    updateInfoCard(galaxyData.find((g) => g.name === name));
                    highlightConnections(name);
                }
            } else if (activeGalaxy) {
                setGalaxyGlow(activeGalaxy, 0);
                activeGalaxy = null;
                updateInfoCard(null);
                highlightConnections(null);
            }
        }

        function highlightConnections(name) {
            connectionLines.children.forEach((child) => {
                const material = child.material;
                if (material?.uniforms) {
                    material.uniforms.uColor.value.copy(child.userData.baseColor ?? connectionBaseColor);
                    material.uniforms.uHighlight.value = 0;
                    child.userData.targetOpacity = child.userData.baseOpacity ?? material.uniforms.uOpacity.value;
                }
            });

            galaxyData.forEach((data) => {
                const entry = galaxyGroups.get(data.name);
                if (!entry) return;
                entry.label.classList.remove("active");
                if (data.name !== activeGalaxy && data.name !== hoveredGalaxy) {
                    setGalaxyGlow(data.name, 0);
                }
            });

            if (!name) {
                return;
            }

            const sourceData = galaxyData.find((g) => g.name === name);
            if (!sourceData) return;

            const related = new Set([name, ...sourceData.connections]);
            connectionLines.children.forEach((child) => {
                const { start, end } = child.userData;
                if (related.has(start) && related.has(end)) {
                    const highlightEntry = galaxyGroups.get(name);
                    if (highlightEntry && child.material?.uniforms) {
                        child.material.uniforms.uColor.value.copy(highlightEntry.core.material.color);
                        child.material.uniforms.uHighlight.value = 1;
                        const baseOpacity = child.userData.baseOpacity ?? 0.34;
                        child.userData.targetOpacity = Math.min(1, baseOpacity + 0.55);
                    }
                }
            });

            related.forEach((labelName) => {
                const entry = galaxyGroups.get(labelName);
                if (!entry) return;
                entry.label.classList.add("active");
                if (labelName !== name && labelName !== hoveredGalaxy) {
                    setGalaxyGlow(labelName, 0.35);
                }
            });
        }

        window.addEventListener("pointermove", onPointerMove);
        window.addEventListener("click", onClick);

        const clusterMovePercent = 0.05;
        const zoomStepPercent = 0.1;
        let customAnimationActive = false;
        let customAnimationPaused = false;
        let customAnimationPhase = 0;

        const leftControl = document.getElementById("controlLeft");
        const rightControl = document.getElementById("controlRight");
        const zoomInControl = document.getElementById("controlZoomIn");
        const zoomOutControl = document.getElementById("controlZoomOut");
        const animateControl = document.getElementById("controlAnimate");

        function panCluster(direction) {
            camera.getWorldDirection(cameraDirection);
            panRight.crossVectors(cameraDirection, camera.up);
            if (panRight.lengthSq() === 0) {
                return;
            }

            const distance = camera.position.distanceTo(controls.target);
            const delta = distance * clusterMovePercent * direction;
            panRight.normalize().multiplyScalar(delta);

            camera.position.add(panRight);
            controls.target.add(panRight);
            controls.update();
            updateLabels();
        }

        function zoomCluster(amount) {
            zoomOffset.subVectors(camera.position, controls.target);
            const currentDistance = zoomOffset.length();
            if (currentDistance === 0) {
                zoomOffset.set(0, 0, 1);
            }

            const targetDistance = THREE.MathUtils.clamp(
                zoomOffset.length() * (1 + amount),
                controls.minDistance,
                controls.maxDistance
            );

            zoomOffset.setLength(targetDistance);
            camera.position.copy(controls.target).add(zoomOffset);
            controls.update();
            updateLabels();
        }

        leftControl?.addEventListener("click", () => {
            panCluster(-1);
        });

        rightControl?.addEventListener("click", () => {
            panCluster(1);
        });

        zoomInControl?.addEventListener("click", () => {
            zoomCluster(-zoomStepPercent);
        });

        zoomOutControl?.addEventListener("click", () => {
            zoomCluster(zoomStepPercent);
        });

        function toggleCustomAnimation() {
            customAnimationActive = !customAnimationActive;
            if (!customAnimationActive) {
                customAnimationPhase = 0;
                customAnimationPaused = false;
                animateControl?.classList.remove("paused");
            }
            if (animateControl) {
                animateControl.classList.toggle("active", customAnimationActive);
                animateControl.setAttribute("aria-pressed", String(customAnimationActive));
                const label = animateControl.querySelector(".label");
                if (label) {
                    label.textContent = customAnimationActive ? "Animating" : "Animate";
                }
            }
        }

        animateControl?.addEventListener("click", () => {
            toggleCustomAnimation();
        });

        animateControl?.addEventListener("mouseenter", () => {
            if (!customAnimationActive) return;
            customAnimationPaused = true;
            animateControl.classList.add("paused");
        });

        animateControl?.addEventListener("mouseleave", () => {
            if (!customAnimationActive) return;
            customAnimationPaused = false;
            animateControl.classList.remove("paused");
        });

        function updateLabels() {
            const rect = renderer.domElement.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            if (!width || !height) {
                return;
            }

            galaxyData.forEach((data) => {
                const entry = galaxyGroups.get(data.name);
                if (!entry) return;
                entry.group.getWorldPosition(tempWorldPosition);
                projectedPosition.copy(tempWorldPosition).project(camera);
                const x = (projectedPosition.x * 0.5 + 0.5) * width;
                const y = (-projectedPosition.y * 0.5 + 0.5) * height;
                const isVisible = projectedPosition.z > -1 && projectedPosition.z < 1;
                entry.label.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                entry.label.style.opacity = isVisible
                    ? entry.label.classList.contains("active")
                        ? 1
                        : 0.7
                    : 0;
            });
        }

        let previousTime = 0;

        function animate(time) {
                if (!isOmniscientPage && !isLunaComposePage && renderer && scene && camera && controls) {
            requestAnimationFrame(animate);
            controls.update();

            const deltaMs = time - (previousTime || time);
            previousTime = time;
            const deltaSeconds = deltaMs > 0 ? deltaMs * 0.001 : 0;

            const t = time * 0.00012;

            if (customAnimationActive) {
                if (!customAnimationPaused) {
                    customAnimationPhase += 0.0045;
                }
                const swingX = Math.sin(customAnimationPhase * 0.55) * 0.18;
                const swingZ = Math.cos(customAnimationPhase * 0.45) * 0.14;
                const lift = Math.sin(customAnimationPhase) * 18;
                superclusterGroup.rotation.x = swingX;
                superclusterGroup.rotation.z = swingZ;
                superclusterGroup.position.y = lift;
            }

            const idleTilt = Math.sin(time * 0.00018) * 0.06;
            const idleLift = Math.sin(time * 0.00012) * 8;
            if (!customAnimationActive) {
                superclusterGroup.rotation.x = THREE.MathUtils.lerp(superclusterGroup.rotation.x, idleTilt, 0.04);
                superclusterGroup.rotation.z = THREE.MathUtils.lerp(superclusterGroup.rotation.z, idleTilt * 0.45, 0.04);
                superclusterGroup.position.y = THREE.MathUtils.lerp(superclusterGroup.position.y, idleLift, 0.06);
            }

            superclusterGroup.rotation.y += 0.00006 + (customAnimationActive && !customAnimationPaused ? 0.00005 : 0.00002);
            atmosphereShell.rotation.y += 0.00001;

            starField.rotation.y += 0.00005;
            starField.rotation.x = Math.sin(time * 0.00006) * 0.05;
            farStarField.rotation.y += 0.000015;
            farStarField.rotation.x = Math.sin(time * 0.00003) * 0.03;

            nebulaClouds.forEach((cloud, idx) => {
                const data = cloud.userData || {};
                const phase = time * 0.00008 + (data.phaseOffset || 0) + idx * 0.1;
                const basePosition = data.basePosition || cloud.position;
                const drift = data.drift || { x: 0, y: 0, z: 0 };
                const driftX = drift.x || 0;
                const driftY = drift.y || 0;
                const driftZ = drift.z || 0;
                cloud.position.x = basePosition.x + Math.sin(phase) * driftX;
                cloud.position.y = basePosition.y + Math.cos(phase * 0.8) * driftY;
                cloud.position.z = basePosition.z + Math.sin(phase * 1.2) * driftZ;
                cloud.rotation.z += data.rotationSpeed || 0.00008;
                const osc = Math.sin(phase * 1.6);
                const flicker = 0.55 + 0.45 * osc * osc;
                if (cloud.material) {
                    cloud.material.opacity = (data.baseOpacity || cloud.material.opacity) * flicker;
                }
            });

            galaxyData.forEach((data, idx) => {
                const entry = galaxyGroups.get(data.name);
                if (!entry) return;
                entry.stars.rotation.y += 0.00028 + idx * 0.00002;
                entry.stars.rotation.x += 0.00012;
                if (customAnimationActive && !customAnimationPaused) {
                    entry.stars.rotation.z += 0.00025;
                }
                if (entry.swirl) {
                    const swirlData = entry.swirl.userData || {};
                    entry.swirl.rotation.z += (swirlData.spinSpeed || 0.00024) + (customAnimationActive && !customAnimationPaused ? 0.00022 : 0);
                    entry.swirl.rotation.x += Math.sin(time * 0.00022 + idx) * (swirlData.wobbleStrength || 0.08) * 0.0025;
                }
                if (entry.sparkLayer) {
                    const spinSpeed = entry.sparkLayer.userData?.spinSpeed || 0.00032;
                    entry.sparkLayer.rotation.z += spinSpeed;
                }
                // Animate galaxy clouds
                if (entry.cloud1) {
                    entry.cloud1.rotation.z += 0.00008;
                    entry.cloud1.rotation.x = Math.PI / 2 + Math.sin(time * 0.00022 + idx) * 0.06;
                }
                if (entry.cloud2) {
                    entry.cloud2.rotation.z -= 0.00006;
                    entry.cloud2.rotation.x = Math.PI / 2.1 + Math.sin(time * 0.00018 + idx) * 0.08;
                }
                if (entry.outerCloud) {
                    entry.outerCloud.rotation.z -= 0.00008;
                    entry.outerCloud.rotation.x = Math.PI / 2.15 + Math.sin(time * 0.00018 + idx) * 0.12;
                }
                
                // Animate dust particles
                if (entry.dust) {
                    const dustSpeed = entry.dust.userData?.spinSpeed || 0.00008;
                    entry.dust.rotation.z += dustSpeed;
                    entry.dust.rotation.y += dustSpeed * 0.5;
                }
                const pulseScale = customAnimationActive
                    ? 1 + Math.sin(customAnimationPhase * 1.4 + idx) * 0.08
                    : 1;
                entry.core.scale.setScalar(pulseScale);
                const haloPulse = customAnimationActive
                    ? Math.sin(customAnimationPhase + idx) * 0.08
                    : 0;
                entry.halo.scale.setScalar(1.22 + Math.sin(t + idx) * 0.02 + haloPulse);
                if (entry.halo2) {
                    entry.halo2.scale.setScalar(1.15 + Math.sin(t + idx * 0.8) * 0.015 + haloPulse * 0.8);
                }
                if (entry.halo3) {
                    entry.halo3.scale.setScalar(1.12 + Math.sin(t + idx * 0.6) * 0.01 + haloPulse * 0.6);
                }
            });

            connectionFlowEntries.forEach((mesh) => {
                const material = mesh.material;
                if (!material?.uniforms) {
                    return;
                }
                const speed = mesh.userData?.flowSpeed || 0.12;
                material.uniforms.uTime.value = (material.uniforms.uTime.value + deltaSeconds * speed) % 1;
                const targetOpacity = mesh.userData?.targetOpacity ?? mesh.userData?.baseOpacity ?? material.uniforms.uOpacity.value;
                material.uniforms.uOpacity.value = THREE.MathUtils.lerp(
                    material.uniforms.uOpacity.value,
                    targetOpacity,
                    0.08
                );
            });

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(
                Array.from(galaxyGroups.values()).map((entry) => entry.core),
                false
            );

            if (intersects.length > 0) {
                const name = galaxyData.find((g) => galaxyGroups.get(g.name).core === intersects[0].object)?.name;
                if (name && name !== hoveredGalaxy) {
                    if (hoveredGalaxy && hoveredGalaxy !== activeGalaxy) {
                        setGalaxyGlow(hoveredGalaxy, 0);
                    }
                    hoveredGalaxy = name;
                    if (name !== activeGalaxy) {
                        setGalaxyGlow(name, 0.6);
                    }
                }
            } else if (hoveredGalaxy && hoveredGalaxy !== activeGalaxy) {
                const previous = hoveredGalaxy;
                setGalaxyGlow(previous, 0);
                hoveredGalaxy = null;
                if (activeGalaxy) {
                    highlightConnections(activeGalaxy);
                }
            }

            updateLabels();
            renderer.render(scene, camera);
                }
        }

        // Initialize the application
        updateInfoCard(null);
        
        // Add debugging for Three.js initialization
        console.log('Starting Supercluster initialization...');
        console.log('Root container:', rootContainer);
        console.log('License key from URL:', licenseKey);

            if (!isOmniscientPage && !isLunaComposePage) {
        animate(0);
            }

        window.addEventListener("resize", () => {
                if (!isOmniscientPage && !isLunaComposePage && camera && renderer) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
                    if (typeof updateLabels === 'function') {
            updateLabels();
                    }
                }
        });
        }

        setTimeout(() => {
            const infoCard = document.getElementById('infoCard');
            if (infoCard) {
                infoCard.classList.add("visible");
            }
        }, 600);

        // ============================================================
        // Luna Chat Widget Integration
        // ============================================================
        async function checkAndLoadLunaWidget() {
            console.log('[Luna Widget] Starting widget load check...');
            const container = document.getElementById('vlLunaChatContainer');
            if (!container) {
                console.error('[Luna Widget] Container not found: vlLunaChatContainer');
                return;
            }
            console.log('[Luna Widget] Container found:', container);

            try {
                // Get license key from URL or page
                let licenseKey = new URLSearchParams(window.location.search).get('license') || 
                                  document.getElementById('licenseKeyDisplay')?.textContent?.trim();
                
                // Extract just the license key (before first /) if URL contains path segments
                if (licenseKey) {
                    const licenseMatch = licenseKey.match(/^([^/]+)/);
                    if (licenseMatch) {
                        licenseKey = licenseMatch[1];
                    }
                }
                
                console.log('[Luna Widget] License key:', licenseKey);
                
                if (!licenseKey) {
                    console.warn('[Luna Widget] No license key found, skipping widget load');
                    return;
                }

                // Get client profile data from VL Hub API to get the shortcode
                const profileUrl = `https://visiblelight.ai/wp-json/vl-hub/v1/profile?license=${encodeURIComponent(licenseKey)}`;
                console.log('[Luna Widget] Fetching profile from:', profileUrl);
                
                const profileResponse = await fetch(profileUrl, {
                    method: 'GET',
                    credentials: 'include',
                    mode: 'cors'
                });

                console.log('[Luna Widget] Profile response status:', profileResponse.status);

                if (!profileResponse.ok) {
                    const errorText = await profileResponse.text();
                    console.error('[Luna Widget] Failed to fetch profile:', profileResponse.status, errorText);
                    return;
                }

                const profileData = await profileResponse.json();
                console.log('[Luna Widget] Profile data received:', profileData);
                
                // Check if profile data is valid (it may not have an 'ok' property)
                if (!profileData || (!profileData.ok && !profileData.license_key && !profileData.site)) {
                    console.error('[Luna Widget] Invalid profile data:', profileData);
                    return;
                }

                // Extract shortcode from profile - check both site_info and direct properties
                let shortcode = null;
                if (profileData.site_info?.luna_supercluster_shortcode) {
                    shortcode = profileData.site_info.luna_supercluster_shortcode;
                } else if (profileData.luna_supercluster_shortcode) {
                    shortcode = profileData.luna_supercluster_shortcode;
                } else {
                    // Default shortcode
                    shortcode = `[luna_chat vl_key=${licenseKey}]`;
                }
                
                console.log('[Luna Widget] Shortcode from profile:', shortcode);
                
                // Parse shortcode to extract vl_key - handle both [luna_chat vl_key=XXX] and [luna_chat vl_key="XXX"]
                let shortcodeMatch = shortcode.match(/\[luna_chat\s+vl_key=["']?([^"'\]]+)["']?\]/);
                if (!shortcodeMatch || !shortcodeMatch[1]) {
                    // Try without quotes
                    shortcodeMatch = shortcode.match(/\[luna_chat\s+vl_key=([^\]]+)\]/);
                }
                
                if (!shortcodeMatch || !shortcodeMatch[1]) {
                    console.error('[Luna Widget] Invalid shortcode format:', shortcode);
                    console.error('[Luna Widget] Attempting to use license key directly...');
                    // Fallback: use license key directly
                    var vlKey = licenseKey;
                } else {
                    var vlKey = shortcodeMatch[1].trim();
                }
                
                console.log('[Luna Widget] Extracted vl_key:', vlKey);
                
                // Get client site URL from profile - check multiple possible locations
                let clientSiteUrl = null;
                if (profileData.site_info?.site) {
                    clientSiteUrl = profileData.site_info.site;
                } else if (profileData.site?.home_url) {
                    clientSiteUrl = profileData.site.home_url;
                } else if (profileData.home_url) {
                    clientSiteUrl = profileData.home_url;
                } else if (profileData.site) {
                    clientSiteUrl = typeof profileData.site === 'string' ? profileData.site : profileData.site.home_url;
                }
                
                console.log('[Luna Widget] Client site URL:', clientSiteUrl);
                
                if (!clientSiteUrl) {
                    console.error('[Luna Widget] No client site URL found in profile');
                    console.error('[Luna Widget] Profile data structure:', JSON.stringify(profileData, null, 2));
                    return;
                }

                // Fetch the widget HTML/CSS/JS from the client's WordPress site with vl_key parameter
                const widgetHtmlUrl = `${clientSiteUrl.replace(/\/$/, '')}/wp-json/luna_widget/v1/widget/html?vl_key=${encodeURIComponent(vlKey)}`;
                
                console.log('[Luna Widget] Fetching widget from:', widgetHtmlUrl);
                
                try {
                    const widgetResponse = await fetch(widgetHtmlUrl, {
                        method: 'GET',
                        credentials: 'include',
                        mode: 'cors'
                    });
                    
                    console.log('[Luna Widget] Widget response status:', widgetResponse.status);
                    
                    if (widgetResponse.ok) {
                        const widgetData = await widgetResponse.json();
                        console.log('[Luna Widget] Widget data received:', widgetData);
                        
                        if (widgetData.ok && widgetData.html) {
                            console.log('[Luna Widget] Injecting widget HTML/CSS/JS...');
                            
                            // Inject CSS first
                            if (widgetData.css) {
                                const style = document.createElement('style');
                                style.id = 'luna-widget-embed-styles';
                                style.textContent = widgetData.css;
                                // Remove existing styles if present
                                const existing = document.getElementById('luna-widget-embed-styles');
                                if (existing) existing.remove();
                                document.head.appendChild(style);
                                console.log('[Luna Widget] CSS injected');
                            }
                            
                            // Inject HTML
                            container.innerHTML = widgetData.html;
                            console.log('[Luna Widget] HTML injected into container');
                            
                            // Inject JavaScript after a short delay to ensure DOM is ready
                            if (widgetData.js) {
                                setTimeout(function() {
                                    const script = document.createElement('script');
                                    script.id = 'luna-widget-embed-script';
                                    // Remove existing script if present
                                    const existing = document.getElementById('luna-widget-embed-script');
                                    if (existing) existing.remove();
                                    script.textContent = widgetData.js;
                                    document.body.appendChild(script);
                                    console.log('[Luna Widget] Widget loaded successfully from shortcode:', shortcode);
                                    console.log('[Luna Widget] Container innerHTML length:', container.innerHTML.length);
                                }, 100);
                            } else {
                                console.warn('[Luna Widget] Widget HTML loaded, but no JavaScript provided');
                            }
                            return;
                        } else if (widgetData.error) {
                            console.error('[Luna Widget] Widget not available:', widgetData.error);
                            container.innerHTML = '<p style="color:#d63638;font-size:0.9rem;">Luna Widget: ' + (widgetData.error || 'Not available') + '</p>';
                            return;
                        } else {
                            console.error('[Luna Widget] Widget data missing ok or html:', widgetData);
                            return;
                        }
                    } else {
                        const errorText = await widgetResponse.text();
                        console.error('[Luna Widget] Failed to fetch widget:', widgetResponse.status, errorText);
                        
                        if (widgetResponse.status === 403) {
                            container.innerHTML = '<p style="color:#d63638;font-size:0.9rem;">Luna Widget: License validation failed or widget mode disabled</p>';
                        } else {
                            container.innerHTML = '<p style="color:#d63638;font-size:0.9rem;">Luna Widget: Failed to load (HTTP ' + widgetResponse.status + ')</p>';
                        }
                        return;
                    }
                } catch (e) {
                    console.error('[Luna Widget] Could not fetch widget HTML:', e);
                    container.innerHTML = '<p style="color:#d63638;font-size:0.9rem;">Luna Widget: Connection error - ' + (e.message || String(e)) + '</p>';
                    return;
                }
                
            } catch (error) {
                console.error('[Luna Widget] Error loading widget:', error);
                const container = document.getElementById('vlLunaChatContainer');
                if (container) {
                    container.innerHTML = '<p style="color:#d63638;font-size:0.9rem;">Luna Widget: Error - ' + (error.message || String(error)) + '</p>';
                }
            }
        }

            // Load widget after page initialization - try multiple times to ensure DOM is ready
            console.log('[Luna Widget] Scheduling widget load...');
            setTimeout(checkAndLoadLunaWidget, 1000);
            setTimeout(checkAndLoadLunaWidget, 2000);
            setTimeout(checkAndLoadLunaWidget, 3000);

            // Widget hide/show toggle functionality
            function initWidgetToggle() {
            const toggleButtons = document.querySelectorAll('.vl-widget-toggle');
            
            toggleButtons.forEach(function(button) {
                // Skip if already initialized
                if (button.dataset.initialized === 'true') return;
                button.dataset.initialized = 'true';
                
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const widgetId = button.getAttribute('data-widget');
                    const widget = document.getElementById(widgetId);
                    if (!widget) return;
                    
                    const widgetBody = widget.querySelector('.vl-widget-body');
                    if (!widgetBody) return;
                    
                    const isHidden = widgetBody.classList.contains('vl-widget-body-hidden');
                    
                    // Get or create the icon element
                    let icon = button.querySelector('.vl-toggle-icon');
                    if (!icon) {
                        icon = document.createElement('img');
                        icon.className = 'vl-toggle-icon';
                        button.appendChild(icon);
                    }
                    
                    if (isHidden) {
                        // Show the widget body
                        widgetBody.classList.remove('vl-widget-body-hidden');
                        icon.src = 'https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-hide-icon.svg';
                        icon.alt = 'Hide';
                        button.setAttribute('aria-label', 'Hide widget');
                    } else {
                        // Hide the widget body
                        widgetBody.classList.add('vl-widget-body-hidden');
                        icon.src = 'https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-icon.svg';
                        icon.alt = 'Show';
                        button.setAttribute('aria-label', 'Show widget');
                    }
                });
            });
        }
        
        // Initialize on DOM ready or immediately if already loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initWidgetToggle);
        } else {
            initWidgetToggle();
        }
        // ============================================================
        // Luna Composer Functions
        // ============================================================
        
        // Use a canned prompt - send to Luna and populate editor
        // Make it globally accessible
        // Scroll function for canned prompts list
        window.scrollCannedPrompts = function(button, direction) {
            const wrapper = button.closest('.canned-prompts-wrapper');
            if (!wrapper) return;
            
            const list = wrapper.querySelector('.canned-prompts-list');
            if (!list) return;
            
            // Scroll amount (adjust as needed)
            const scrollAmount = 400;
            const currentScroll = list.scrollLeft;
            const newScroll = currentScroll + (scrollAmount * direction);
            
            list.scrollTo({
                left: newScroll,
                behavior: 'smooth'
            });
            
            // Update arrow visibility after a short delay to allow scroll to complete
            setTimeout(() => {
                updateCannedPromptsArrows(list, wrapper);
            }, 100);
        };
        
        // Update arrow visibility based on scroll position
        function updateCannedPromptsArrows(list, wrapper) {
            if (!list || !wrapper) return;
            
            const leftBtn = wrapper.querySelector('.canned-prompts-scroll-left');
            const rightBtn = wrapper.querySelector('.canned-prompts-scroll-right');
            
            if (!leftBtn || !rightBtn) return;
            
            const scrollLeft = list.scrollLeft;
            const scrollWidth = list.scrollWidth;
            const clientWidth = list.clientWidth;
            const maxScroll = scrollWidth - clientWidth;
            
            // Show/hide left arrow
            if (scrollLeft > 0) {
                leftBtn.style.display = 'block';
            } else {
                leftBtn.style.display = 'none';
            }
            
            // Show/hide right arrow
            if (scrollLeft < maxScroll - 1) { // -1 for rounding issues
                rightBtn.style.display = 'block';
            } else {
                rightBtn.style.display = 'none';
            }
        }
        
        // Initialize scroll arrows when Luna Composer is rendered
        function initializeCannedPromptsScroll() {
            const list = document.querySelector('.canned-prompts-list');
            if (!list) return;
            
            const wrapper = list.closest('.canned-prompts-wrapper');
            if (!wrapper) return;
            
            // Initial check
            updateCannedPromptsArrows(list, wrapper);
            
            // Update on scroll
            list.addEventListener('scroll', () => {
                updateCannedPromptsArrows(list, wrapper);
            });
            
            // Update on resize
            window.addEventListener('resize', () => {
                updateCannedPromptsArrows(list, wrapper);
            });
        }
        
        // Toggle between Canned Prompts and Intelligent Suggestions modes
        window.lunaComposerToggleMode = function() {
            const toggle = document.getElementById('luna-composer-mode-toggle');
            const title = document.getElementById('luna-composer-section-title');
            const cannedSection = document.getElementById('luna-composer-canned-section');
            const reimagineWrapper = document.getElementById('luna-composer-reimagine-wrapper');
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');
            const cannedBtn = document.getElementById('luna-composer-mode-canned');
            const intelligentBtn = document.getElementById('luna-composer-mode-intelligent');

            if (!toggle || !title || !cannedSection || !reimagineWrapper || !reimagineBtn || !cannedBtn || !intelligentBtn) {
                console.error('[Luna Composer] Toggle elements not found');
                return;
            }

            const currentMode = toggle.getAttribute('data-mode');
            const newMode = currentMode === 'canned' ? 'intelligent' : 'canned';

            toggle.setAttribute('data-mode', newMode);

            if (newMode === 'intelligent') {
                // Switch to Intelligent Suggestions
                title.textContent = 'Intelligent Suggestions';
                cannedSection.style.display = 'none';
                reimagineWrapper.style.display = 'flex';

                // Update toggle button styles
                cannedBtn.style.background = 'transparent';
                cannedBtn.style.color = '#9A9793';
                intelligentBtn.style.background = '#2E2C2A';
                intelligentBtn.style.color = '#fff4e9';

                updateReimagineButtonState();
            } else {
                // Switch to Canned Prompts
                title.textContent = 'Canned Prompts';
                cannedSection.style.display = 'block';
                reimagineWrapper.style.display = 'none';

                // Update toggle button styles
                cannedBtn.style.background = '#2E2C2A';
                cannedBtn.style.color = '#fff4e9';
                intelligentBtn.style.background = 'transparent';
                intelligentBtn.style.color = '#9A9793';

                if (window.lunaComposerReimagineState) {
                    window.lunaComposerReimagineState.currentMode = null;
                    window.lunaComposerReimagineState.highlightRange = null;
                }
                resetReimagineButton();
                hideReimagineMenu();
                hideHighlightTooltip();
            }
        };

        function resetReimagineButton() {
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');
            if (!reimagineBtn) return;

            reimagineBtn.style.pointerEvents = 'none';
            reimagineBtn.style.cursor = 'not-allowed';
            reimagineBtn.style.color = '#9A9793';
            reimagineBtn.style.background = '#2E2C2A50';
            reimagineBtn.disabled = true;

            const span = reimagineBtn.querySelector('span');
            if (span) {
                span.textContent = 'Reimagine with Luna';
            }

            reimagineBtn.removeAttribute('data-active-mode');
        }

        function updateReimagineButtonState() {
            const toggle = document.getElementById('luna-composer-mode-toggle');
            const editor = document.getElementById('luna-composer-editor');
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');

            if (!toggle || !editor || !reimagineBtn) {
                return;
            }

            const mode = toggle.getAttribute('data-mode');
            const text = editor.innerText || editor.textContent || '';
            const hasContent = text.trim().length > 0;

            if (mode === 'intelligent' && hasContent) {
                reimagineBtn.style.pointerEvents = 'auto';
                reimagineBtn.style.cursor = 'pointer';
                reimagineBtn.style.color = '#fff4e9';
                reimagineBtn.style.background = '#2E2C2A';
                reimagineBtn.disabled = false;
            } else {
                resetReimagineButton();
                hideReimagineMenu();
                if (window.lunaComposerReimagineState) {
                    window.lunaComposerReimagineState.currentMode = null;
                    window.lunaComposerReimagineState.highlightRange = null;
                }
                hideHighlightTooltip();
            }
        }

        function ensureReimagineState() {
            if (!window.lunaComposerReimagineState) {
                window.lunaComposerReimagineState = {
                    currentMode: null,
                    highlightRange: null
                };
            }
            return window.lunaComposerReimagineState;
        }

        function hideReimagineMenu() {
            const menu = document.getElementById('luna-composer-reimagine-menu');
            if (menu) {
                menu.style.display = 'none';
            }
        }

        function hideHighlightTooltip() {
            const tooltip = document.getElementById('luna-composer-highlight-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }

            const state = ensureReimagineState();
            state.highlightRange = null;
        }

        window.lunaComposerToggleReimagineMenu = function(event) {
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');
            const menu = document.getElementById('luna-composer-reimagine-menu');

            if (!reimagineBtn || !menu || reimagineBtn.disabled) {
                return;
            }

            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }

            const isOpen = menu.style.display === 'block';
            hideReimagineMenu();

            if (!isOpen) {
                menu.style.display = 'block';
            }
        };

        window.lunaComposerSelectReimagineMode = function(mode) {
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');
            const editor = document.getElementById('luna-composer-editor');
            const state = ensureReimagineState();

            hideReimagineMenu();

            if (!reimagineBtn || !editor) {
                return;
            }

            const span = reimagineBtn.querySelector('span');

            if (mode === 'highlight') {
                if (state.currentMode === 'highlight') {
                    state.currentMode = null;
                    reimagineBtn.removeAttribute('data-active-mode');
                    if (span) {
                        span.textContent = 'Reimagine with Luna';
                    }
                    hideHighlightTooltip();
                } else {
                    state.currentMode = 'highlight';
                    reimagineBtn.setAttribute('data-active-mode', 'highlight');
                    if (span) {
                        span.textContent = 'Highlight to Reimagine';
                    }
                    handleHighlightSelection();
                }
                return;
            }

            state.currentMode = null;
            reimagineBtn.removeAttribute('data-active-mode');
            if (span) {
                span.textContent = 'Reimagine with Luna';
            }

            hideHighlightTooltip();

            if (mode === 'branding' || mode === 'linguistics') {
                reimagineFullDocument(mode);
            }
        };

        function handleHighlightSelection() {
            const state = ensureReimagineState();
            if (state.currentMode !== 'highlight') {
                hideHighlightTooltip();
                return;
            }

            const editor = document.getElementById('luna-composer-editor');
            const tooltip = document.getElementById('luna-composer-highlight-tooltip');
            if (!editor || !tooltip) {
                return;
            }

            const selection = window.getSelection();
            if (!selection || selection.rangeCount === 0) {
                hideHighlightTooltip();
                return;
            }

            const range = selection.getRangeAt(0);
            if (!editor.contains(range.commonAncestorContainer)) {
                hideHighlightTooltip();
                return;
            }

            const selectedText = selection.toString();
            if (!selectedText || !selectedText.trim()) {
                hideHighlightTooltip();
                return;
            }

            const rect = range.getBoundingClientRect();
            tooltip.style.display = 'flex';
            tooltip.style.top = Math.max(16, rect.top - 12) + 'px';
            tooltip.style.left = rect.left + rect.width / 2 + 'px';
            tooltip.style.transform = 'translate(-50%, -100%)';

            state.highlightRange = range.cloneRange();
        }

        window.lunaComposerReimagineHighlightedText = async function() {
            const state = ensureReimagineState();
            const range = state.highlightRange;
            const tooltip = document.getElementById('luna-composer-highlight-tooltip');
            const actionBtn = document.getElementById('luna-composer-highlight-action');

            if (!range || !actionBtn) {
                hideHighlightTooltip();
                return;
            }

            const selectedText = range.toString();
            if (!selectedText || !selectedText.trim()) {
                hideHighlightTooltip();
                return;
            }

            const originalLabel = actionBtn.textContent;
            actionBtn.disabled = true;
            actionBtn.textContent = 'Reimagining...';

            try {
                const answer = await requestLunaReimagine('highlight', selectedText.trim());
                if (answer) {
                    replaceRangeWithContent(range, answer);
                    updateReimagineButtonState();
                    setTimeout(() => {
                        window.lunaComposerUpdateHeartState();
                    }, 100);
                }
            } catch (error) {
                console.error('[Luna Composer] Highlight reimagine failed:', error);
                alert('Failed to reimagine the highlighted text. Please try again.');
            } finally {
                actionBtn.disabled = false;
                actionBtn.textContent = originalLabel;
                hideHighlightTooltip();
            }
        };

        async function reimagineFullDocument(mode) {
            const editor = document.getElementById('luna-composer-editor');
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');
            if (!editor || !reimagineBtn) {
                return;
            }

            const text = editor.innerText || editor.textContent || '';
            if (!text.trim()) {
                alert('Please enter some text to reimagine.');
                return;
            }

            const span = reimagineBtn.querySelector('span');
            const originalLabel = span ? span.textContent : '';

            reimagineBtn.disabled = true;
            reimagineBtn.style.pointerEvents = 'none';
            reimagineBtn.style.cursor = 'wait';
            if (span) {
                span.textContent = 'Reimagining...';
            }

            const originalHtml = editor.innerHTML;
            editor.innerHTML = '<div class="luna-composer-loading-text" style="display: flex; align-items: center; justify-content: center; padding: 40px; text-align: center;"><div class="luna-composer-loading-icon"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" stroke-dasharray="31.416" stroke-dashoffset="31.416" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="2s" values="0 31.416;15.708 15.708;0 31.416;0 31.416" repeatCount="indefinite"/><animate attributeName="stroke-dashoffset" dur="2s" values="0;-15.708;-31.416;-31.416" repeatCount="indefinite"/></circle></svg></div><span class="luna-composer-loading-text">Luna is considering all possibilities...</span></div>';

            try {
                const answer = await requestLunaReimagine(mode, text.trim());
                if (answer) {
                    editor.innerHTML = formatComposerAnswer(answer);
                    editor.scrollTop = 0;
                    editor.dispatchEvent(new Event('input', { bubbles: true }));
                    setTimeout(() => {
                        window.lunaComposerUpdateHeartState();
                    }, 100);
                } else {
                    throw new Error('No response from Luna');
                }
            } catch (error) {
                console.error('[Luna Composer] Error reimagining document:', error);
                alert('Failed to reimagine content. Please try again.');
                editor.innerHTML = originalHtml;
            } finally {
                if (span) {
                    span.textContent = 'Reimagine with Luna';
                }
                reimagineBtn.disabled = false;
                reimagineBtn.style.pointerEvents = 'auto';
                reimagineBtn.style.cursor = 'pointer';
                reimagineBtn.style.background = '#2E2C2A';
                reimagineBtn.style.color = '#fff4e9';
                updateReimagineButtonState();
            }
        }

        async function requestLunaReimagine(mode, text) {
            const licenseKey = extractLicenseKey();
            if (!licenseKey) {
                throw new Error('License key not found');
            }

            let message;
            if (mode === 'highlight') {
                message = 'Please refine and enhance the following highlighted selection using Luna\'s GPT-4o and VL Hub insights. Preserve the intent and context while improving clarity and impact.\n\n' + text;
            } else if (mode === 'branding') {
                message = 'Please rewrite the following content with a compelling brand voice that aligns with the client\'s business, leveraging VL Hub data and historical insights. Maintain key information while elevating tone and resonance.\n\n' + text;
            } else if (mode === 'linguistics') {
                message = 'Please revise the following content for grammar, linguistics, and readability using Luna\'s advanced checks while keeping the original message intact.\n\n' + text;
            } else {
                message = text;
            }

            const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({
                    message: message,
                    license: licenseKey,
                    context: 'composer'
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText || response.statusText}`);
            }

            const data = await response.json();
            if (!data || !data.answer) {
                throw new Error('No response from Luna');
            }

            return data.answer;
        }

        function extractLicenseKey() {
            const urlParams = new URLSearchParams(window.location.search);
            const urlLicense = urlParams.get('license') || '';
            if (!urlLicense) {
                return '';
            }

            const match = urlLicense.match(/^([^/]+)/);
            if (match) {
                return match[1];
            }

            return urlLicense;
        }

        function formatComposerAnswer(answer) {
            if (!answer) {
                return '';
            }

            const trimmed = answer.trim();
            const hasHtml = /<\/?[a-z][\s\S]*>/i.test(trimmed);
            if (hasHtml) {
                return trimmed;
            }

            const normalized = trimmed.replace(/\r\n/g, '\n');
            const paragraphs = normalized.split(/\n\n+/).map(para => para.replace(/\n/g, '<br>'));
            return '<p>' + paragraphs.join('</p><p>') + '</p>';
        }

        function replaceRangeWithContent(range, content) {
            if (!range) {
                return;
            }

            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                return;
            }

            range.deleteContents();

            let insertionContent = content ? content.trim() : '';
            let nodes = [];

            if (insertionContent && /<\/?[a-z][\s\S]*>/i.test(insertionContent)) {
                const temp = document.createElement('div');
                temp.innerHTML = insertionContent;
                while (temp.firstChild) {
                    nodes.push(temp.firstChild);
                    temp.removeChild(temp.firstChild);
                }
            } else if (insertionContent) {
                nodes.push(document.createTextNode(insertionContent.replace(/\s+/g, ' ').trim()));
            }

            const fragment = document.createDocumentFragment();
            let lastNode = null;
            nodes.forEach(node => {
                lastNode = node;
                fragment.appendChild(node);
            });

            if (fragment.childNodes.length) {
                range.insertNode(fragment);
            }

            const selection = window.getSelection();
            if (selection) {
                selection.removeAllRanges();
                const newRange = document.createRange();

                if (lastNode) {
                    if (lastNode.nodeType === Node.TEXT_NODE) {
                        newRange.setStart(lastNode, lastNode.textContent.length);
                        newRange.setEnd(lastNode, lastNode.textContent.length);
                    } else {
                        newRange.selectNode(lastNode);
                        newRange.collapse(false);
                    }
                } else {
                    newRange.setStart(range.endContainer, range.endOffset);
                    newRange.collapse(true);
                }

                selection.addRange(newRange);
            }

            editor.dispatchEvent(new Event('input', { bubbles: true }));
        }

        function initializeLunaComposerIntelligentMode() {
            const editor = document.getElementById('luna-composer-editor');
            const toggle = document.getElementById('luna-composer-mode-toggle');

            if (!editor || !toggle) {
                return;
            }

            if (!window.lunaComposerIntelligentInitialized) {
                window.lunaComposerIntelligentInitialized = true;

                editor.addEventListener('input', () => {
                    updateReimagineButtonState();
                });

                editor.addEventListener('paste', () => {
                    setTimeout(() => {
                        updateReimagineButtonState();
                    }, 100);
                });

                editor.addEventListener('mouseup', () => {
                    handleHighlightSelection();
                });

                editor.addEventListener('keyup', () => {
                    handleHighlightSelection();
                });

                document.addEventListener('selectionchange', () => {
                    const state = ensureReimagineState();
                    if (state.currentMode === 'highlight') {
                        handleHighlightSelection();
                    }
                });

                document.addEventListener('click', (event) => {
                    const wrapper = document.getElementById('luna-composer-reimagine-wrapper');
                    const tooltip = document.getElementById('luna-composer-highlight-tooltip');
                    const menu = document.getElementById('luna-composer-reimagine-menu');

                    if (menu && menu.style.display === 'block' && wrapper && !wrapper.contains(event.target)) {
                        hideReimagineMenu();
                    }

                    if (tooltip && tooltip.style.display === 'flex') {
                        if (!tooltip.contains(event.target) && !editor.contains(event.target)) {
                            hideHighlightTooltip();
                        }
                    }
                });

                window.addEventListener('scroll', () => {
                    const state = ensureReimagineState();
                    if (state.currentMode === 'highlight') {
                        hideHighlightTooltip();
                    }
                }, true);

                window.addEventListener('resize', () => {
                    const state = ensureReimagineState();
                    if (state.currentMode === 'highlight') {
                        hideHighlightTooltip();
                    }
                });
            }

            const highlightAction = document.getElementById('luna-composer-highlight-action');
            if (highlightAction && !highlightAction.dataset.listenerAttached) {
                highlightAction.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    window.lunaComposerReimagineHighlightedText();
                });
                highlightAction.dataset.listenerAttached = 'true';
            }

            updateReimagineButtonState();
        }
        
        window.lunaComposerUsePrompt = async function(promptId, promptText, responseContent) {
            console.log('[Luna Composer] Using prompt:', promptId, promptText);
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            // Generate new document ID for this prompt
            const licenseKey = editor.getAttribute('data-license-key');
            if (!licenseKey) {
                console.error('[Luna Composer] License key not found');
                return;
            }
            
            const documentId = 'doc_' + Date.now() + '_' + Math.random().toString(36).substring(2, 11);
            editor.setAttribute('data-document-id', documentId);
            editor.setAttribute('data-prompt', promptText);
            
            // Update URL with new document ID
            const currentParams = new URLSearchParams(window.location.search);
            const currentLicense = currentParams.get('license') || '';
            if (currentLicense) {
                const baseLicense = currentLicense.split('/luna/compose/')[0];
                const newUrl = new URL(window.location.href);
                newUrl.searchParams.set('license', baseLicense + '/luna/compose/' + documentId);
                window.history.replaceState({}, '', newUrl.toString());
            }
            
            // Show loading state with circular loading icon and gradient text
            editor.innerHTML = '<p style="display: flex; align-items: center; padding: 20px; margin: 0;"><svg class="luna-composer-loading-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="width: 20px; height: 20px; flex-shrink: 0;"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-dasharray="31.416" stroke-dashoffset="23.562" opacity="0.6"><animate attributeName="stroke-dashoffset" dur="1.5s" values="31.416;0" repeatCount="indefinite"/></circle></svg><span class="luna-composer-loading-text">Luna is considering all possibilities...</span></p>';
            
            // Always send prompt to Luna (don't use canned response content directly)
            // Luna will use GPT-4o + VL Hub data to generate a thoughtful response
            try {
                console.log('[Luna Composer] Sending prompt to Luna API...');
                const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        prompt: promptText,
                        context: 'composer',
                        license: licenseKey
                    })
                });
                
                console.log('[Luna Composer] Response status:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('[Luna Composer] Response data:', data);
                    if (data.answer) {
                        // Convert newlines to <br> tags and preserve formatting
                        let formattedAnswer = data.answer.replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>');
                        if (!formattedAnswer.startsWith('<p>')) {
                            formattedAnswer = '<p>' + formattedAnswer + '</p>';
                        }
                        editor.innerHTML = formattedAnswer;
                        editor.scrollTop = 0;
                        console.log('[Luna Composer] Response displayed in editor');
                        
                        // Show and initialize heart icon state (defaults to dislike)
                        setTimeout(() => {
                            const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
                            if (heartBtn) {
                                heartBtn.style.display = 'flex';
                            }
                            window.lunaComposerUpdateHeartState();
                        }, 100);
                        
                        // Auto-save the new document
                        const documentData = {
                            id: documentId,
                            content: formattedAnswer,
                            prompt: promptText,
                            timestamp: Date.now(),
                            license: licenseKey,
                            feedback: 'dislike' // Default to dislike for new documents
                        };
                        
                        const docKey = `luna_composer_doc_${documentId}`;
                        localStorage.setItem(docKey, JSON.stringify(documentData));
                        
                        // Add to history
                        const historyKey = `luna_composer_history_${licenseKey}`;
                        let history = [];
                        try {
                            const historyStr = localStorage.getItem(historyKey);
                            if (historyStr) {
                                history = JSON.parse(historyStr);
                            }
                        } catch (e) {
                            console.warn('[Luna Composer] Could not parse history:', e);
                        }
                        
                        // Find existing entry with same document ID and update it, or add new
                        const existingIndex = history.findIndex(doc => doc.id === documentId);
                        if (existingIndex !== -1) {
                            // Update existing entry
                            history[existingIndex].prompt = promptText;
                            history[existingIndex].timestamp = Date.now();
                        } else {
                            // Add new entry to beginning of history
                            history.unshift({
                                id: documentId,
                                prompt: promptText,
                                timestamp: Date.now()
                            });
                        }
                        
                        if (history.length > 50) {
                            history = history.slice(0, 50);
                        }
                        
                        localStorage.setItem(historyKey, JSON.stringify(history));
                        
                        // Save to WordPress via REST API
                        fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/save', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify({
                                license: licenseKey,
                                document_id: documentId,
                                prompt: promptText,
                                content: formattedAnswer
                            })
                        }).then(response => {
                            if (response.ok) {
                                console.log('[Luna Composer] Document saved to WordPress');
                                
                                // Show "Saved to VL Cloud" message with fade-in
                                const saveMessage = document.getElementById('luna-composer-save-message');
                                if (saveMessage) {
                                    // Ensure transition is set for fade-in
                                    saveMessage.style.transition = 'opacity 0.3s ease';
                                    saveMessage.textContent = 'Saved to VL Cloud';
                                    saveMessage.style.color = '#fff4e9';
                                    saveMessage.style.opacity = '1';
                                    
                                    // Fade out after 5 seconds
                                    setTimeout(() => {
                                        saveMessage.style.transition = 'opacity 0.5s ease';
                                        saveMessage.style.opacity = '0';
                                        // Clear text after fade completes
                                        setTimeout(() => {
                                            saveMessage.textContent = '';
                                        }, 500);
                                    }, 5000);
                                }
                                
                                // Add activity notification to main Supercluster page (not on /luna/compose/)
                                const currentParams = new URLSearchParams(window.location.search);
                                const currentLicense = currentParams.get('license') || '';
                                const isLunaComposePage = currentLicense.includes('/luna/compose/');
                                
                                if (!isLunaComposePage) {
                                    // Add to activity stream
                                    const activityList = document.getElementById('recentActivityList');
                                    if (activityList) {
                                        const now = new Date();
                                        const activityItem = document.createElement('li');
                                        activityItem.className = 'vl-activity-item';
                                        
                                        const timeSpan = document.createElement('span');
                                        timeSpan.id = 'activityTimeStamp';
                                        timeSpan.textContent = now.toLocaleString();
                                        activityItem.appendChild(timeSpan);
                                        activityItem.appendChild(document.createElement('br'));
                                        
                                        const labelText = document.createTextNode('Luna Compose Doc was created');
                                        activityItem.appendChild(labelText);
                                        
                                        // Remove "No recent activity" if present
                                        const emptyItem = activityList.querySelector('.vl-activity-empty');
                                        if (emptyItem) {
                                            emptyItem.remove();
                                        }
                                        
                                        // Insert at the beginning
                                        activityList.insertBefore(activityItem, activityList.firstChild);
                                        
                                        // Keep only last 10 items
                                        const items = activityList.querySelectorAll('.vl-activity-item');
                                        if (items.length > 10) {
                                            for (let i = 10; i < items.length; i++) {
                                                items[i].remove();
                                            }
                                        }
                                    }
                                }
                            } else {
                                console.warn('[Luna Composer] Failed to save to WordPress:', response.status);
                            }
                        }).catch(e => {
                            console.warn('[Luna Composer] Error saving to WordPress:', e);
                        });
                        
                        // Refresh history list
                        loadLunaComposerHistory();
                    } else {
                        editor.innerHTML = '<p style="color: #d63638;">Error: No answer received from Luna</p>';
                    }
                } else {
                    const errorText = await response.text();
                    console.error('[Luna Composer] API error:', response.status, errorText);
                    editor.innerHTML = '<p style="color: #d63638;">Error: Failed to get response from Luna (HTTP ' + response.status + ')</p>';
                }
            } catch (e) {
                console.error('[Luna Composer] Error sending prompt:', e);
                editor.innerHTML = '<p style="color: #d63638;">Error: ' + (e.message || 'Failed to connect to Luna') + '</p>';
            }
        };
        
        // Initialize auto-save with document ID generation
        function initializeLunaComposerAutoSave() {
            const editor = document.getElementById('luna-composer-editor');
            const statusEl = document.getElementById('luna-composer-auto-save-status');
            if (!editor) return;
            
            let saveTimeout = null;
            let lastSaved = null;
            const licenseKey = editor.getAttribute('data-license-key');
            let documentId = editor.getAttribute('data-document-id');
            
            // Generate document ID if not present
            if (!documentId || documentId === '') {
                documentId = 'doc_' + Date.now() + '_' + Math.random().toString(36).substring(2, 11);
                editor.setAttribute('data-document-id', documentId);
                
                // Update URL with document ID
                const currentParams = new URLSearchParams(window.location.search);
                const currentLicense = currentParams.get('license') || '';
                if (currentLicense) {
                    const baseLicense = currentLicense.split('/luna/compose/')[0];
                    const newUrl = new URL(window.location.href);
                    newUrl.searchParams.set('license', baseLicense + '/luna/compose/' + documentId);
                    window.history.replaceState({}, '', newUrl.toString());
                }
            }
            
            // Auto-save on input
            editor.addEventListener('input', () => {
                // Auto-saving state - icon remains visible, no message
                const saveMessage = document.getElementById('luna-composer-save-message');
                if (saveMessage) {
                    saveMessage.textContent = '';
                    saveMessage.style.opacity = '0';
                }
                
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    const content = editor.innerHTML;
                    const prompt = editor.getAttribute('data-prompt') || '';
                    
                    if (!licenseKey) return;
                    
                    // Save document with metadata
                    const documentData = {
                        id: documentId,
                        content: content,
                        prompt: prompt,
                        timestamp: Date.now(),
                        license: licenseKey
                    };
                    
                    // Save to localStorage with document ID
                    const docKey = `luna_composer_doc_${documentId}`;
                    localStorage.setItem(docKey, JSON.stringify(documentData));
                    
                    // Also save to history list
                    const historyKey = `luna_composer_history_${licenseKey}`;
                    let history = [];
                    try {
                        const historyStr = localStorage.getItem(historyKey);
                        if (historyStr) {
                            history = JSON.parse(historyStr);
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not parse history:', e);
                    }
                    
                    // Find existing entry with same document ID and update it
                    const existingIndex = history.findIndex(doc => doc.id === documentId);
                    if (existingIndex !== -1) {
                        // Update existing entry
                        history[existingIndex].prompt = prompt || 'Untitled Document';
                        history[existingIndex].timestamp = Date.now();
                    } else {
                        // Add new entry to beginning of history
                        history.unshift({
                            id: documentId,
                            prompt: prompt || 'Untitled Document',
                            timestamp: Date.now()
                        });
                    }
                    
                    // Keep only last 50 documents
                    if (history.length > 50) {
                        history = history.slice(0, 50);
                    }
                    
                    localStorage.setItem(historyKey, JSON.stringify(history));
                    
                    // Save to WordPress via REST API
                    fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({
                            license: licenseKey,
                            document_id: documentId,
                            prompt: prompt,
                            content: content
                        })
                    }).then(response => {
                        if (response.ok) {
                            console.log('[Luna Composer] Document saved to WordPress');
                            
                            // Show "Saved to VL Cloud" message with fade-in
                            const saveMessage = document.getElementById('luna-composer-save-message');
                            if (saveMessage) {
                                // Ensure transition is set for fade-in
                                saveMessage.style.transition = 'opacity 0.3s ease';
                                saveMessage.textContent = 'Saved to VL Cloud';
                                saveMessage.style.color = '#fff4e9';
                                saveMessage.style.opacity = '1';
                                
                                // Fade out after 5 seconds
                                setTimeout(() => {
                                    saveMessage.style.transition = 'opacity 0.5s ease';
                                    saveMessage.style.opacity = '0';
                                    // Clear text after fade completes
                                    setTimeout(() => {
                                        saveMessage.textContent = '';
                                    }, 500);
                                }, 5000);
                            }
                            
                            // Add activity notification to main Supercluster page (not on /luna/compose/)
                            const currentParams = new URLSearchParams(window.location.search);
                            const currentLicense = currentParams.get('license') || '';
                            const isLunaComposePage = currentLicense.includes('/luna/compose/');
                            
                            if (!isLunaComposePage) {
                                // Add to activity stream
                                const activityList = document.getElementById('recentActivityList');
                                if (activityList) {
                                    const now = new Date();
                                    const activityItem = document.createElement('li');
                                    activityItem.className = 'vl-activity-item';
                                    
                                    const timeSpan = document.createElement('span');
                                    timeSpan.id = 'activityTimeStamp';
                                    timeSpan.textContent = now.toLocaleString();
                                    activityItem.appendChild(timeSpan);
                                    activityItem.appendChild(document.createElement('br'));
                                    
                                    const labelText = document.createTextNode('Luna Compose Doc was created');
                                    activityItem.appendChild(labelText);
                                    
                                    // Remove "No recent activity" if present
                                    const emptyItem = activityList.querySelector('.vl-activity-empty');
                                    if (emptyItem) {
                                        emptyItem.remove();
                                    }
                                    
                                    // Insert at the beginning
                                    activityList.insertBefore(activityItem, activityList.firstChild);
                                    
                                    // Keep only last 10 items
                                    const items = activityList.querySelectorAll('.vl-activity-item');
                                    if (items.length > 10) {
                                        for (let i = 10; i < items.length; i++) {
                                            items[i].remove();
                                        }
                                    }
                                }
                            }
                        } else {
                            console.warn('[Luna Composer] Failed to save to WordPress:', response.status);
                        }
                    }).catch(e => {
                        console.warn('[Luna Composer] Error saving to WordPress:', e);
                    });
                    
                    lastSaved = new Date();
                    
                    // Refresh history list
                    loadLunaComposerHistory();
                }, 2000); // Save after 2 seconds of inactivity
            });
            
            // Load saved content on page load
            if (documentId && documentId !== '') {
                const docKey = `luna_composer_doc_${documentId}`;
                const savedDoc = localStorage.getItem(docKey);
                if (savedDoc) {
                    try {
                        const docData = JSON.parse(savedDoc);
                        if (docData.content) {
                            editor.innerHTML = docData.content;
                            if (docData.prompt) {
                                editor.setAttribute('data-prompt', docData.prompt);
                            }
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not parse saved document:', e);
                    }
                }
            } else if (licenseKey) {
                // Fallback: load latest document for this license
                const historyKey = `luna_composer_history_${licenseKey}`;
                const historyStr = localStorage.getItem(historyKey);
                if (historyStr) {
                    try {
                        const history = JSON.parse(historyStr);
                        if (history.length > 0) {
                            const latestDoc = history[0];
                            const docKey = `luna_composer_doc_${latestDoc.id}`;
                            const savedDoc = localStorage.getItem(docKey);
                            if (savedDoc) {
                                const docData = JSON.parse(savedDoc);
                                if (docData.content) {
                                    editor.innerHTML = docData.content;
                                    editor.setAttribute('data-document-id', latestDoc.id);
                                    if (docData.prompt) {
                                        editor.setAttribute('data-prompt', docData.prompt);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not load latest document:', e);
                    }
                }
            }
        }
        
        // Load and display history in sidebar - fetch from WordPress first
        async function loadLunaComposerHistory() {
            const historyList = document.getElementById('lunaComposerHistoryList');
            if (!historyList) return;
            
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) return;
            
            const licenseKey = editor.getAttribute('data-license-key');
            if (!licenseKey) return;
            
            // Try to fetch from WordPress first (last 30 days)
            try {
                const response = await fetch(`https://visiblelight.ai/wp-json/luna_widget/v1/composer/fetch?license=${encodeURIComponent(licenseKey)}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.documents && data.documents.length > 0) {
                        // Update localStorage with WordPress data
                        const history = data.documents.map(doc => ({
                            id: doc.id,
                            prompt: doc.prompt || 'Untitled Document',
                            timestamp: doc.timestamp,
                            feedback: doc.feedback || 'dislike' // Include feedback from WordPress
                        }));
                        
                        const historyKey = `luna_composer_history_${licenseKey}`;
                        localStorage.setItem(historyKey, JSON.stringify(history));
                        
                        // Cache individual documents with feedback
                        data.documents.forEach(doc => {
                            const docKey = `luna_composer_doc_${doc.id}`;
                            localStorage.setItem(docKey, JSON.stringify({
                                id: doc.id,
                                content: doc.content,
                                prompt: doc.prompt,
                                timestamp: doc.timestamp,
                                license: licenseKey,
                                feedback: doc.feedback || 'dislike' // Include feedback from WordPress
                            }));
                            
                            // Also store feedback separately for easy lookup
                            if (doc.feedback) {
                                const feedbackKey = `luna_composer_feedback_${doc.id}`;
                                localStorage.setItem(feedbackKey, JSON.stringify({
                                    feedback: doc.feedback,
                                    timestamp: Date.now()
                                }));
                            }
                        });
                        
                        // Display history
                        displayHistory(history, historyList, editor, licenseKey);
                        return;
                    }
                }
            } catch (e) {
                console.warn('[Luna Composer] Could not fetch history from WordPress:', e);
            }
            
            // Fallback to localStorage
            const historyKey = `luna_composer_history_${licenseKey}`;
            const historyStr = localStorage.getItem(historyKey);
            
            if (!historyStr) {
                historyList.innerHTML = '<li class="vl-activity-empty">No saved documents.</li>';
                return;
            }
            
            try {
                const history = JSON.parse(historyStr);
                
                if (history.length === 0) {
                    historyList.innerHTML = '<li class="vl-activity-empty">No saved documents.</li>';
                    return;
                }
                
                displayHistory(history, historyList, editor, licenseKey);
            } catch (e) {
                console.error('[Luna Composer] Could not parse history:', e);
                historyList.innerHTML = '<li class="vl-activity-empty">Error loading history.</li>';
            }
        }
        
        // Display history list with Liked/Disliked categories
        function displayHistory(history, historyList, editor, licenseKey) {
            historyList.innerHTML = '';
            
            // Separate into liked and disliked
            const likedDocs = [];
            const dislikedDocs = [];
            
            history.forEach(doc => {
                // Check feedback from doc object first (from WordPress), then localStorage
                let feedback = doc.feedback || null;
                
                if (!feedback) {
                    // Check feedback from localStorage document data
                    const docKey = `luna_composer_doc_${doc.id}`;
                    const savedDoc = localStorage.getItem(docKey);
                    if (savedDoc) {
                        try {
                            const docData = JSON.parse(savedDoc);
                            feedback = docData.feedback || null;
                        } catch (e) {
                            console.warn('[Luna Composer] Could not parse doc data:', e);
                        }
                    }
                }
                
                // Also check if feedback was stored separately
                if (!feedback) {
                    const feedbackKey = `luna_composer_feedback_${doc.id}`;
                    const feedbackStr = localStorage.getItem(feedbackKey);
                    if (feedbackStr) {
                        try {
                            const feedbackData = JSON.parse(feedbackStr);
                            feedback = feedbackData.feedback || null;
                        } catch (e) {
                            console.warn('[Luna Composer] Could not parse feedback:', e);
                        }
                    }
                }
                
                // Default to dislike if no feedback found
                if (!feedback) {
                    feedback = 'dislike';
                }
                
                if (feedback === 'like') {
                    likedDocs.push({...doc, feedback: 'like'});
                } else {
                    // Default to dislike for unrated documents
                    dislikedDocs.push({...doc, feedback: 'dislike'});
                }
            });
            
            // Create Liked section
            if (likedDocs.length > 0) {
                const likedSection = document.createElement('div');
                likedSection.className = 'luna-composer-history-section';
                
                const likedHeader = document.createElement('div');
                likedHeader.className = 'luna-composer-history-header';
                likedHeader.style.cssText = 'display: flex; align-items: center; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #1f1d1a; cursor: pointer; user-select: none;';
                likedHeader.onclick = function() {
                    const content = this.nextElementSibling;
                    const arrow = this.querySelector('.luna-composer-section-arrow');
                    if (content.style.display === 'none') {
                        content.style.display = 'block';
                        arrow.style.transform = 'rotate(180deg)';
                    } else {
                        content.style.display = 'none';
                        arrow.style.transform = 'rotate(0deg)';
                    }
                };
                
                const likedTitle = document.createElement('span');
                likedTitle.style.cssText = 'color: #fff4e9; font-weight: 600; font-size: 0.875rem;';
                likedTitle.textContent = 'Liked';
                
                const likedArrow = document.createElement('img');
                likedArrow.className = 'luna-composer-section-arrow';
                likedArrow.src = 'https://visiblelight.ai/wp-content/uploads/2025/08/downarrow.svg';
                likedArrow.style.cssText = 'width: 12px; height: 12px; transition: transform 0.2s ease; transform: rotate(180deg); filter: brightness(0) invert(1);';
                
                likedHeader.appendChild(likedTitle);
                likedHeader.appendChild(likedArrow);
                
                const likedContent = document.createElement('ul');
                likedContent.className = 'luna-composer-history-content';
                likedContent.style.cssText = 'list-style: none; padding: 0; margin: 0;';
                
                // Add liked docs
                likedDocs.forEach(doc => {
                    const li = createHistoryItem(doc, editor, licenseKey);
                    likedContent.appendChild(li);
                });
                
                likedSection.appendChild(likedHeader);
                likedSection.appendChild(likedContent);
                historyList.appendChild(likedSection);
            }
            
            // Create Disliked section
            if (dislikedDocs.length > 0) {
                const dislikedSection = document.createElement('div');
                dislikedSection.className = 'luna-composer-history-section';
                
                const dislikedHeader = document.createElement('div');
                dislikedHeader.className = 'luna-composer-history-header';
                dislikedHeader.style.cssText = 'display: flex; align-items: center; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #1f1d1a; cursor: pointer; user-select: none;';
                dislikedHeader.onclick = function() {
                    const content = this.nextElementSibling;
                    const arrow = this.querySelector('.luna-composer-section-arrow');
                    if (content.style.display === 'none') {
                        content.style.display = 'block';
                        arrow.style.transform = 'rotate(180deg)';
                    } else {
                        content.style.display = 'none';
                        arrow.style.transform = 'rotate(0deg)';
                    }
                };
                
                const dislikedTitle = document.createElement('span');
                dislikedTitle.style.cssText = 'color: #fff4e9; font-weight: 600; font-size: 0.875rem;';
                dislikedTitle.textContent = 'Disliked';
                
                const dislikedArrow = document.createElement('img');
                dislikedArrow.className = 'luna-composer-section-arrow';
                dislikedArrow.src = 'https://visiblelight.ai/wp-content/uploads/2025/08/downarrow.svg';
                dislikedArrow.style.cssText = 'width: 12px; height: 12px; transition: transform 0.2s ease; transform: rotate(0deg); filter: brightness(0) invert(1);';
                
                dislikedHeader.appendChild(dislikedTitle);
                dislikedHeader.appendChild(dislikedArrow);
                
                const dislikedContent = document.createElement('ul');
                dislikedContent.className = 'luna-composer-history-content';
                dislikedContent.style.cssText = 'list-style: none; padding: 0; margin: 0; display: none;';
                
                dislikedDocs.forEach(doc => {
                    const li = createHistoryItem(doc, editor, licenseKey);
                    dislikedContent.appendChild(li);
                });
                
                dislikedSection.appendChild(dislikedHeader);
                dislikedSection.appendChild(dislikedContent);
                historyList.appendChild(dislikedSection);
            }
            
            if (likedDocs.length === 0 && dislikedDocs.length === 0) {
                historyList.innerHTML = '<li class="vl-activity-empty">No saved documents.</li>';
            }
        }
        
        // Create a history item
        function createHistoryItem(doc, editor, licenseKey) {
            const li = document.createElement('li');
            li.className = 'vl-activity-item';
            li.style.cssText = 'padding: 12px; border-bottom: 1px solid #1f1d1a; cursor: pointer; transition: background 0.2s ease; position: relative;';
            li.setAttribute('data-document-id', doc.id);
            
            // Delete button (x icon) - shown on hover
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'luna-composer-history-delete';
            deleteBtn.innerHTML = '×';
            deleteBtn.style.cssText = 'position: absolute; top: 8px; right: 8px; background: transparent; border: none; color: #d63638; font-size: 1.25rem; cursor: pointer; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.2s ease; z-index: 10; line-height: 1;';
            deleteBtn.onclick = function(e) {
                e.stopPropagation();
                window.lunaComposerShowDeleteModalForHistory(doc.id, licenseKey);
            };
            
            li.onmouseover = function() { 
                this.style.background = '#2E2C2A';
                const btn = this.querySelector('.luna-composer-history-delete');
                if (btn) btn.style.opacity = '1';
            };
            li.onmouseout = function() { 
                this.style.background = 'transparent';
                const btn = this.querySelector('.luna-composer-history-delete');
                if (btn) btn.style.opacity = '0';
            };
            
            const title = document.createElement('div');
            title.style.cssText = 'color: #fff4e9; font-weight: 600; font-size: 0.8rem; margin-bottom: 0; padding-right: 30px;';
            title.textContent = doc.prompt || 'Untitled Document';
            
            const timestamp = document.createElement('div');
            timestamp.style.cssText = 'color: #5A5753; font-size: 0.7rem;';
            const date = new Date(doc.timestamp);
            timestamp.textContent = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
            
            li.appendChild(title);
            li.appendChild(timestamp);
            li.appendChild(deleteBtn);
            
            li.onclick = async function() {
                    // Try to load from WordPress first, then localStorage
                    try {
                        const response = await fetch(`https://visiblelight.ai/wp-json/luna_widget/v1/composer/fetch?license=${encodeURIComponent(licenseKey)}&document_id=${encodeURIComponent(doc.id)}`, {
                            method: 'GET',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include'
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            if (data.documents && data.documents.length > 0) {
                                const docData = data.documents[0];
                                if (docData.content) {
                                    editor.innerHTML = docData.content;
                                    editor.setAttribute('data-document-id', doc.id);
                                    if (docData.prompt) {
                                        editor.setAttribute('data-prompt', docData.prompt);
                                    }
                                    
                                    // Show and update heart icon state
                                    setTimeout(() => {
                                        const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
                                        if (heartBtn) {
                                            heartBtn.style.display = 'flex';
                                        }
                                        window.lunaComposerUpdateHeartState();
                                    }, 100);
                                    
                                    // Update URL
                                    const currentParams = new URLSearchParams(window.location.search);
                                    const currentLicense = currentParams.get('license') || '';
                                    if (currentLicense) {
                                        const baseLicense = currentLicense.split('/luna/compose/')[0];
                                        const newUrl = new URL(window.location.href);
                                        newUrl.searchParams.set('license', baseLicense + '/luna/compose/' + doc.id);
                                        window.history.replaceState({}, '', newUrl.toString());
                                    }
                                    
                                    // Cache in localStorage with feedback
                                    const docKey = `luna_composer_doc_${doc.id}`;
                                    localStorage.setItem(docKey, JSON.stringify({
                                        id: doc.id,
                                        content: docData.content,
                                        prompt: docData.prompt,
                                        timestamp: docData.timestamp,
                                        license: licenseKey,
                                        feedback: docData.feedback || 'dislike' // Include feedback from WordPress
                                    }));
                                    
                                    // Also store feedback separately
                                    if (docData.feedback) {
                                        const feedbackKey = `luna_composer_feedback_${doc.id}`;
                                        localStorage.setItem(feedbackKey, JSON.stringify({
                                            feedback: docData.feedback,
                                            timestamp: Date.now()
                                        }));
                                    }
                                    
                                    // Scroll editor to top
                                    editor.scrollTop = 0;
                                    return;
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not fetch document from WordPress:', e);
                    }
                    
                    // Fallback to localStorage
                    const docKey = `luna_composer_doc_${doc.id}`;
                    const savedDoc = localStorage.getItem(docKey);
                    if (savedDoc) {
                        try {
                            const docData = JSON.parse(savedDoc);
                            if (docData.content) {
                                editor.innerHTML = docData.content;
                                editor.setAttribute('data-document-id', doc.id);
                                if (docData.prompt) {
                                    editor.setAttribute('data-prompt', docData.prompt);
                                }
                                
                                // Store feedback if present
                                if (docData.feedback) {
                                    const feedbackKey = `luna_composer_feedback_${doc.id}`;
                                    localStorage.setItem(feedbackKey, JSON.stringify({
                                        feedback: docData.feedback,
                                        timestamp: Date.now()
                                    }));
                                }
                                
                                // Show and update heart icon state
                                setTimeout(() => {
                                    const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
                                    if (heartBtn) {
                                        heartBtn.style.display = 'flex';
                                    }
                                    window.lunaComposerUpdateHeartState();
                                }, 100);
                                
                                // Update URL
                                const currentParams = new URLSearchParams(window.location.search);
                                const currentLicense = currentParams.get('license') || '';
                                if (currentLicense) {
                                    const baseLicense = currentLicense.split('/luna/compose/')[0];
                                    const newUrl = new URL(window.location.href);
                                    newUrl.searchParams.set('license', baseLicense + '/luna/compose/' + doc.id);
                                    window.history.replaceState({}, '', newUrl.toString());
                                }
                                
                                // Scroll editor to top
                                editor.scrollTop = 0;
                            }
                        } catch (e) {
                            console.error('[Luna Composer] Could not load document:', e);
                        }
                    }
                };
                
                return li;
        }
        
        // Find and Replace functions - make globally accessible
        window.lunaComposerShowFindReplace = function() {
            console.log('[Luna Composer] Showing find/replace modal');
            const modal = document.getElementById('luna-composer-find-replace-modal');
            if (modal) {
                modal.style.display = 'flex';
                const findInput = document.getElementById('luna-composer-find-text');
                if (findInput) {
                    findInput.focus();
                }
            } else {
                console.error('[Luna Composer] Find/replace modal not found');
            }
        };
        
        window.lunaComposerCloseFindReplace = function() {
            console.log('[Luna Composer] Closing find/replace modal');
            const modal = document.getElementById('luna-composer-find-replace-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        };
        
        window.lunaComposerExecuteFindReplace = function() {
            console.log('[Luna Composer] Executing find/replace');
            const findText = document.getElementById('luna-composer-find-text');
            const replaceText = document.getElementById('luna-composer-replace-text');
            const editor = document.getElementById('luna-composer-editor');
            
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            if (!findText || !findText.value) {
                alert('Please enter text to find');
                return;
            }
            
            // Get plain text content from editor (not HTML)
            let content = editor.innerText || editor.textContent || '';
            const findValue = findText.value;
            const replaceValue = replaceText ? replaceText.value : '';
            
            // Replace all occurrences (case-insensitive)
            const regex = new RegExp(findValue.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            content = content.replace(regex, replaceValue);
            
            // Update editor with new content
            editor.innerText = content;
            editor.textContent = content;
            
            console.log('[Luna Composer] Find/replace completed');
            window.lunaComposerCloseFindReplace();
        };
        
        // Share functions - make globally accessible
        window.lunaComposerShowShareModal = async function() {
            console.log('[Luna Composer] Showing share modal');
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            const content = editor.innerHTML;
            const prompt = editor.getAttribute('data-prompt') || '';
            
            if (!documentId || !licenseKey) {
                console.error('[Luna Composer] Document ID or license key not found');
                alert('Please save your document before sharing.');
                return;
            }
            
            // Generate unique share ID (longer for uniqueness)
            const shareId = 'lcid_' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 10);
            
            // Save shared document to WordPress backend
            try {
                const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/share', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        license: licenseKey,
                        document_id: documentId,
                        share_id: shareId,
                        content: content,
                        prompt: prompt
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('[Luna Composer] Share link created:', data);
                } else {
                    console.warn('[Luna Composer] Failed to create share link:', response.status);
                }
            } catch (e) {
                console.error('[Luna Composer] Error creating share link:', e);
            }
            
            // Generate secure shareable URL (without license key)
            const shareUrl = `https://supercluster.visiblelight.ai/invite_from/luna/compose/${shareId}`;
            
            // Show modal and set link
            const modal = document.getElementById('luna-composer-share-modal');
            const linkInput = document.getElementById('luna-composer-share-link-input');
            if (modal && linkInput) {
                linkInput.value = shareUrl;
                modal.style.display = 'flex';
            } else {
                console.error('[Luna Composer] Share modal or input not found');
            }
        };
        
        window.lunaComposerCloseShareModal = function() {
            console.log('[Luna Composer] Closing share modal');
            const modal = document.getElementById('luna-composer-share-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        };
        
        window.lunaComposerCopyShareLink = function() {
            console.log('[Luna Composer] Copying share link');
            const linkInput = document.getElementById('luna-composer-share-link-input');
            if (!linkInput) {
                console.error('[Luna Composer] Share link input not found');
                return;
            }
            
            const shareUrl = linkInput.value;
            
            // Copy to clipboard
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(shareUrl).then(() => {
                    const copyBtn = document.getElementById('luna-composer-share-copy-btn');
                    if (copyBtn) {
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = 'Copied!';
                        copyBtn.style.background = '#8D8C00';
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                            copyBtn.style.background = '#fff4e9';
                        }, 2000);
                    }
                    console.log('[Luna Composer] Link copied:', shareUrl);
                }).catch((err) => {
                    console.error('[Luna Composer] Clipboard error:', err);
                    // Fallback
                    linkInput.select();
                    document.execCommand('copy');
                    alert('Shareable link copied to clipboard!');
                });
            } else {
                // Fallback for older browsers
                linkInput.select();
                document.execCommand('copy');
                alert('Shareable link copied to clipboard!');
            }
        };
        
        window.lunaComposerEmail = function() {
            console.log('[Luna Composer] Opening email client');
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const content = editor.innerText || editor.textContent || '';
            const subject = encodeURIComponent('Luna Composer Document');
            const body = encodeURIComponent(content);
            const mailtoLink = `mailto:?subject=${subject}&body=${body}`;
            
            window.location.href = mailtoLink;
            window.lunaComposerToggleShareMenu();
        };
        
        // Export functions - make globally accessible
        window.lunaComposerToggleExportMenu = function() {
            console.log('[Luna Composer] Toggling export menu');
            const menu = document.getElementById('luna-composer-export-menu');
            const btn = document.getElementById('luna-composer-export-btn');
            if (menu && btn) {
                const isVisible = menu.style.display === 'block' || menu.style.display === '';
                if (isVisible) {
                    menu.style.display = 'none';
                } else {
                    // Calculate position relative to button
                    const btnRect = btn.getBoundingClientRect();
                    menu.style.position = 'fixed';
                    menu.style.top = (btnRect.bottom + 8) + 'px';
                    menu.style.left = btnRect.left + 'px';
                    menu.style.display = 'block';
                    // Force backdrop-filter styles
                    menu.style.setProperty('background', 'rgba(0,0,0,0.85)', 'important');
                    menu.style.setProperty('backdrop-filter', 'blur(12px)', 'important');
                    menu.style.setProperty('-webkit-backdrop-filter', 'blur(12px)', 'important');
                    menu.style.setProperty('z-index', '10000', 'important');
                    menu.style.setProperty('isolation', 'isolate', 'important');
                }
            } else {
                console.error('[Luna Composer] Export menu or button not found');
            }
        };
        
        window.lunaComposerExportTo = function(format) {
            console.log('[Luna Composer] Exporting to:', format);
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const content = editor.innerText || editor.textContent || '';
            const htmlContent = editor.innerHTML;
            
            if (format === 'google-docs') {
                // Open Google Docs in new tab
                const url = 'https://docs.google.com/document/create?usp=sharing';
                window.open(url, '_blank');
                // Note: Google Docs doesn't support direct content injection via URL
                // User will need to paste content manually
                alert('Google Docs opened in a new tab. Please paste your content manually.');
            } else if (format === 'csv') {
                // Export as CSV
                const csvContent = '"Content"\n"' + content.replace(/"/g, '""') + '"';
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'luna-composer-' + Date.now() + '.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                console.log('[Luna Composer] CSV exported');
            } else if (format === 'pdf') {
                // Export as PDF with exact formatting using browser print
                const printWindow = window.open('', '_blank');
                if (!printWindow) {
                    alert('Please allow popups to export as PDF');
                    return;
                }
                
                // Create a styled document that preserves formatting
                printWindow.document.write(`
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <title>Luna Composer Export</title>
                            <meta charset="utf-8">
                            <style>
                                body { 
                                    font-family: Arial, sans-serif; 
                                    padding: 40px; 
                                    color: #000; 
                                    background: #fff;
                                    line-height: 1.6;
                                }
                                .content { 
                                    white-space: pre-wrap;
                                    word-wrap: break-word;
                                }
                                p { margin: 1em 0; }
                                strong { font-weight: bold; }
                                em { font-style: italic; }
                                u { text-decoration: underline; }
                                s { text-decoration: line-through; }
                                ul, ol { margin: 1em 0; padding-left: 2em; }
                            </style>
                        </head>
                        <body>
                            <div class="content">${htmlContent}</div>
                        </body>
                    </html>
                `);
                printWindow.document.close();
                
                // Wait for content to load, then print
                setTimeout(() => {
                    printWindow.print();
                }, 250);
                console.log('[Luna Composer] PDF export initiated');
            } else if (format === 'mp3') {
                // Export as MP3 audio file
                if (!content.trim()) {
                    alert('No text to convert to audio.');
                    return;
                }
                
                // Show loading message
                const exportBtn = document.getElementById('luna-composer-export-btn');
                if (exportBtn) {
                    const originalText = exportBtn.textContent;
                    exportBtn.textContent = 'Generating audio...';
                    exportBtn.disabled = true;
                    
                    try {
                        // Use Web Speech API to generate audio
                        const synth = window.speechSynthesis;
                        if (!synth) {
                            throw new Error('Speech synthesis not supported');
                        }
                        
                        // Create utterance
                        const utterance = new SpeechSynthesisUtterance(content);
                        utterance.lang = 'en-US';
                        utterance.rate = 1.0;
                        utterance.pitch = 1.0;
                        utterance.volume = 1.0;
                        
                        // Use MediaRecorder API to record the speech
                        // Note: This requires a MediaStream, which we'll create from the audio context
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const destination = audioContext.createMediaStreamDestination();
                        
                        // Create a MediaRecorder to capture the audio
                        const mediaRecorder = new MediaRecorder(destination.stream);
                        const chunks = [];
                        
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                chunks.push(event.data);
                            }
                        };
                        
                        mediaRecorder.onstop = () => {
                            const blob = new Blob(chunks, { type: 'audio/webm' });
                            
                            // Convert WebM to MP3 using a library or service
                            // For now, we'll download as WebM and note that MP3 conversion requires server-side processing
                            // In a production environment, you'd send this to a server to convert to MP3
                            
                            // For client-side conversion, we can use a library like lamejs
                            // But for simplicity, we'll download as WebM and note the limitation
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'luna-composer-' + Date.now() + '.webm';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            
                            // Note: WebM to MP3 conversion typically requires server-side processing
                            // For now, downloading as WebM. To get MP3, you'd need to:
                            // 1. Send the WebM blob to a server endpoint
                            // 2. Convert using ffmpeg or similar tool
                            // 3. Return the MP3 file
                            
                            alert('Audio exported as WebM. Note: MP3 conversion requires server-side processing. The file can be converted using online tools or server-side conversion.');
                            
                            if (exportBtn) {
                                exportBtn.textContent = originalText;
                                exportBtn.disabled = false;
                            }
                        };
                        
                        // Start recording
                        mediaRecorder.start();
                        
                        // Speak the text
                        utterance.onend = () => {
                            setTimeout(() => {
                                mediaRecorder.stop();
                            }, 500); // Small delay to ensure all audio is captured
                        };
                        
                        synth.speak(utterance);
                        
                    } catch (error) {
                        console.error('[Luna Composer] Error generating audio:', error);
                        alert('Error generating audio file. Please try again or use a different browser.');
                        if (exportBtn) {
                            exportBtn.textContent = originalText;
                            exportBtn.disabled = false;
                        }
                    }
                }
            }
            
            window.lunaComposerToggleExportMenu();
        };
        
        // Dictate functionality
        let recognition = null;
        let isDictating = false;
        
        window.lunaComposerToggleDictate = function() {
            const editor = document.getElementById('luna-composer-editor');
            const dictateBtn = document.getElementById('luna-composer-dictate-btn');
            
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            // Check if browser supports Speech Recognition
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                alert('Speech recognition is not supported in your browser. Please use Chrome, Edge, or Safari.');
                return;
            }
            
            if (!isDictating) {
                // Start dictation
                if (!recognition) {
                    recognition = new SpeechRecognition();
                    recognition.continuous = true;
                    recognition.interimResults = true;
                    recognition.lang = 'en-US';
                    
                    recognition.onresult = function(event) {
                        let interimTranscript = '';
                        let finalTranscript = '';
                        
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            const transcript = event.results[i][0].transcript;
                            if (event.results[i].isFinal) {
                                finalTranscript += transcript + ' ';
                            } else {
                                interimTranscript += transcript;
                            }
                        }
                        
                        if (finalTranscript) {
                            // Insert final transcript at cursor position
                            const selection = window.getSelection();
                            if (selection.rangeCount > 0) {
                                const range = selection.getRangeAt(0);
                                range.deleteContents();
                                const textNode = document.createTextNode(finalTranscript);
                                range.insertNode(textNode);
                                range.setStartAfter(textNode);
                                range.collapse(true);
                                selection.removeAllRanges();
                                selection.addRange(range);
                            } else {
                                // Append to end if no selection
                                editor.textContent += finalTranscript;
                            }
                        }
                    };
                    
                    recognition.onerror = function(event) {
                        console.error('[Luna Composer] Speech recognition error:', event.error);
                        if (event.error === 'no-speech') {
                            alert('No speech detected. Please try again.');
                        } else if (event.error === 'not-allowed') {
                            alert('Microphone permission denied. Please allow microphone access.');
                        }
                        isDictating = false;
                        if (dictateBtn) {
                            dictateBtn.textContent = 'Dictate';
                            dictateBtn.style.background = '#2E2C2A50';
                        }
                    };
                    
                    recognition.onend = function() {
                        isDictating = false;
                        if (dictateBtn) {
                            dictateBtn.textContent = 'Dictate';
                            dictateBtn.style.background = '#2E2C2A50';
                        }
                    };
                }
                
                try {
                    recognition.start();
                    isDictating = true;
                    if (dictateBtn) {
                        dictateBtn.textContent = 'Stop Dictating';
                        dictateBtn.style.background = '#d63638';
                    }
                } catch (e) {
                    console.error('[Luna Composer] Error starting recognition:', e);
                    alert('Error starting speech recognition. Please try again.');
                }
            } else {
                // Stop dictation
                if (recognition) {
                    recognition.stop();
                    isDictating = false;
                    if (dictateBtn) {
                        dictateBtn.textContent = 'Dictate';
                        dictateBtn.style.background = '#2E2C2A50';
                    }
                }
            }
        };
        
        // Audio readback functionality
        let synth = window.speechSynthesis;
        let isReading = false;
        let currentUtterance = null;
        
        window.lunaComposerToggleReadback = function() {
            const editor = document.getElementById('luna-composer-editor');
            const readbackBtn = document.getElementById('luna-composer-readback-btn');
            
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            if (!synth) {
                alert('Speech synthesis is not supported in your browser.');
                return;
            }
            
            if (isReading) {
                // Stop reading
                synth.cancel();
                isReading = false;
                if (readbackBtn) {
                    readbackBtn.textContent = 'Read Aloud';
                    readbackBtn.style.background = '#2E2C2A50';
                }
            } else {
                // Start reading
                const text = editor.innerText || editor.textContent || '';
                if (!text.trim()) {
                    alert('No text to read.');
                    return;
                }
                
                // Cancel any ongoing speech
                synth.cancel();
                
                currentUtterance = new SpeechSynthesisUtterance(text);
                currentUtterance.lang = 'en-US';
                currentUtterance.rate = 1.0;
                currentUtterance.pitch = 1.0;
                currentUtterance.volume = 1.0;
                
                currentUtterance.onend = function() {
                    isReading = false;
                    if (readbackBtn) {
                        readbackBtn.textContent = 'Read Aloud';
                        readbackBtn.style.background = '#2E2C2A50';
                    }
                };
                
                currentUtterance.onerror = function(event) {
                    console.error('[Luna Composer] Speech synthesis error:', event.error);
                    isReading = false;
                    if (readbackBtn) {
                        readbackBtn.textContent = 'Read Aloud';
                        readbackBtn.style.background = '#2E2C2A50';
                    }
                };
                
                synth.speak(currentUtterance);
                isReading = true;
                if (readbackBtn) {
                    readbackBtn.textContent = 'Stop Reading';
                    readbackBtn.style.background = '#d63638';
                }
            }
        };
        
        // Delete functions - make globally accessible
        window.lunaComposerShowDeleteModal = function() {
            console.log('[Luna Composer] Showing delete modal');
            const modal = document.getElementById('luna-composer-delete-modal');
            if (modal) {
                modal.style.display = 'flex';
                // Reset delete button state
                const deleteBtn = document.getElementById('luna-composer-delete-confirm');
                if (deleteBtn) {
                    deleteBtn.disabled = true;
                    deleteBtn.style.opacity = '0.5';
                    deleteBtn.style.cursor = 'not-allowed';
                }
            } else {
                console.error('[Luna Composer] Delete modal not found');
            }
        };
        
        window.lunaComposerCloseDeleteModal = function() {
            console.log('[Luna Composer] Closing delete modal');
            const modal = document.getElementById('luna-composer-delete-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        };
        
        window.lunaComposerDownloadBackup = function() {
            console.log('[Luna Composer] Downloading backup');
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const content = editor.innerText || editor.textContent || '';
            const htmlContent = editor.innerHTML;
            
            // Export as PDF with exact formatting using browser print
            const printWindow = window.open('', '_blank');
            if (!printWindow) {
                alert('Please allow popups to download backup');
                return;
            }
            
            // Create a styled document that preserves formatting
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                    <head>
                        <title>Luna Composer Backup</title>
                        <meta charset="utf-8">
                        <style>
                            body { 
                                font-family: Arial, sans-serif; 
                                padding: 40px; 
                                color: #000; 
                                background: #fff;
                                line-height: 1.6;
                            }
                            .content { 
                                white-space: pre-wrap;
                                word-wrap: break-word;
                            }
                            p { margin: 1em 0; }
                            strong { font-weight: bold; }
                            em { font-style: italic; }
                            u { text-decoration: underline; }
                            s { text-decoration: line-through; }
                            ul, ol { margin: 1em 0; padding-left: 2em; }
                        </style>
                    </head>
                    <body>
                        <div class="content">${htmlContent}</div>
                    </body>
                </html>
            `);
            printWindow.document.close();
            
            // Wait for content to load, then print
            setTimeout(() => {
                printWindow.print();
            }, 250);
            
            // Enable delete button after download
            const deleteBtn = document.getElementById('luna-composer-delete-confirm');
            if (deleteBtn) {
                deleteBtn.disabled = false;
                deleteBtn.style.opacity = '1';
                deleteBtn.style.cursor = 'pointer';
            }
        };
        
        window.lunaComposerDeleteDocument = async function() {
            console.log('[Luna Composer] Deleting document');
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            
            if (!documentId || !licenseKey) {
                console.error('[Luna Composer] Document ID or license key not found');
                return;
            }
            
            try {
                // Delete from WordPress
                const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        license: licenseKey,
                        document_id: documentId
                    })
                });
                
                if (response.ok) {
                    console.log('[Luna Composer] Document deleted from WordPress');
                } else {
                    console.warn('[Luna Composer] Failed to delete from WordPress:', response.status);
                }
            } catch (e) {
                console.warn('[Luna Composer] Error deleting from WordPress:', e);
            }
            
            // Delete from localStorage
            const docKey = `luna_composer_doc_${documentId}`;
            localStorage.removeItem(docKey);
            
            // Remove from history
            const historyKey = `luna_composer_history_${licenseKey}`;
            const historyStr = localStorage.getItem(historyKey);
            if (historyStr) {
                try {
                    const history = JSON.parse(historyStr);
                    const filteredHistory = history.filter(doc => doc.id !== documentId);
                    localStorage.setItem(historyKey, JSON.stringify(filteredHistory));
                } catch (e) {
                    console.warn('[Luna Composer] Could not update history:', e);
                }
            }
            
            // Add activity notification to main Supercluster page (not on /luna/compose/)
            const currentParams = new URLSearchParams(window.location.search);
            const currentLicense = currentParams.get('license') || '';
            const isLunaComposePage = currentLicense.includes('/luna/compose/');
            
            if (!isLunaComposePage) {
                // Add to activity stream
                const activityList = document.getElementById('recentActivityList');
                if (activityList) {
                    const now = new Date();
                    const activityItem = document.createElement('li');
                    activityItem.className = 'vl-activity-item';
                    
                    const timeSpan = document.createElement('span');
                    timeSpan.id = 'activityTimeStamp';
                    timeSpan.textContent = now.toLocaleString();
                    activityItem.appendChild(timeSpan);
                    activityItem.appendChild(document.createElement('br'));
                    
                    const labelText = document.createTextNode('Luna Compose Document was deleted');
                    activityItem.appendChild(labelText);
                    
                    // Remove "No recent activity" if present
                    const emptyItem = activityList.querySelector('.vl-activity-empty');
                    if (emptyItem) {
                        emptyItem.remove();
                    }
                    
                    // Insert at the beginning
                    activityList.insertBefore(activityItem, activityList.firstChild);
                    
                    // Keep only last 10 items
                    const items = activityList.querySelectorAll('.vl-activity-item');
                    if (items.length > 10) {
                        for (let i = 10; i < items.length; i++) {
                            items[i].remove();
                        }
                    }
                }
            }
            
            // Close modal
            window.lunaComposerCloseDeleteModal();
            
            // Reload composer screen
            const baseLicense = currentLicense.split('/luna/compose/')[0];
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set('license', baseLicense + '/luna/compose/');
            window.location.href = newUrl.toString();
        };
        
        // Like/Dislike feedback functionality - initialize after DOM is ready
        function initializeFeedbackButtons() {
            const editorWrapper = document.getElementById('luna-composer-editor-wrapper');
            const editor = document.getElementById('luna-composer-editor');
            const feedbackButtons = document.getElementById('luna-composer-feedback-buttons');
            
            if (editorWrapper && editor && feedbackButtons) {
                // Show feedback buttons on hover
                editorWrapper.addEventListener('mouseenter', () => {
                    feedbackButtons.style.display = 'flex';
                });
                
                editorWrapper.addEventListener('mouseleave', (e) => {
                    // Check if mouse is moving to feedback buttons
                    const relatedTarget = e.relatedTarget;
                    if (!relatedTarget || (!feedbackButtons.contains(relatedTarget) && !editorWrapper.contains(relatedTarget))) {
                        // Small delay to allow clicking the buttons
                        setTimeout(() => {
                            if (!feedbackButtons.matches(':hover') && !editorWrapper.matches(':hover')) {
                                feedbackButtons.style.display = 'none';
                            }
                        }, 200);
                    }
                });
                
                // Keep buttons visible when hovering over them
                feedbackButtons.addEventListener('mouseenter', () => {
                    feedbackButtons.style.display = 'flex';
                });
                
                feedbackButtons.addEventListener('mouseleave', () => {
                    setTimeout(() => {
                        if (!editorWrapper.matches(':hover')) {
                            feedbackButtons.style.display = 'none';
                        }
                    }, 200);
                });
            }
        }
        
        // Initialize feedback buttons when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeFeedbackButtons);
        } else {
            // DOM is already ready
            setTimeout(initializeFeedbackButtons, 500); // Small delay to ensure elements are created
        }
        
        // Toggle heart icon (like/dislike)
        window.lunaComposerToggleHeart = async function() {
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            
            if (!documentId || !licenseKey) {
                console.error('[Luna Composer] Document ID or license key not found');
                return;
            }
            
            // Check current state
            const heartIcon = document.getElementById('luna-composer-heart-icon');
            const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
            
            if (!heartIcon || !heartBtn) {
                console.error('[Luna Composer] Heart icon or button not found');
                return;
            }
            
            // Determine current state from icon src
            const currentSrc = heartIcon.getAttribute('src');
            const isLiked = currentSrc.includes('heart-solid-full.svg');
            const newFeedbackType = isLiked ? 'dislike' : 'like';
            
            // Call the main feedback function
            await window.lunaComposerSubmitFeedback(newFeedbackType);
            
            // Update icon based on new state
            if (newFeedbackType === 'like') {
                heartIcon.setAttribute('src', 'https://visiblelight.ai/wp-content/uploads/2025/11/heart-solid-full.svg');
                heartBtn.style.background = '#000000';
                heartBtn.style.borderColor = '#1f1d1a';
            } else {
                heartIcon.setAttribute('src', 'https://visiblelight.ai/wp-content/uploads/2025/11/heart-regular-full-1.svg');
                heartBtn.style.background = '#2E2C2A50';
                heartBtn.style.borderColor = '#1f1d1a';
            }
            
            // Reload history to reflect changes
            setTimeout(() => {
                loadLunaComposerHistory();
            }, 500);
        };
        
        // Initialize heart icon state when document loads
        window.lunaComposerUpdateHeartState = async function() {
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) return;
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            
            if (!documentId || !licenseKey) return;
            
            const heartIcon = document.getElementById('luna-composer-heart-icon');
            const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
            
            if (!heartIcon || !heartBtn) return;
            
            // First, try to fetch feedback from WordPress (most reliable - survives cache clears)
            let isLiked = false;
            try {
                const response = await fetch(`https://visiblelight.ai/wp-json/luna_widget/v1/composer/fetch?license=${encodeURIComponent(licenseKey)}&document_id=${encodeURIComponent(documentId)}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.documents && data.documents.length > 0) {
                        const docData = data.documents[0];
                        if (docData.feedback === 'like') {
                            isLiked = true;
                            // Update localStorage with WordPress data
                            const feedbackKey = `luna_composer_feedback_${documentId}`;
                            localStorage.setItem(feedbackKey, JSON.stringify({
                                feedback: 'like',
                                timestamp: Date.now()
                            }));
                            const docKey = `luna_composer_doc_${documentId}`;
                            const savedDoc = localStorage.getItem(docKey);
                            if (savedDoc) {
                                try {
                                    const docDataLocal = JSON.parse(savedDoc);
                                    docDataLocal.feedback = 'like';
                                    localStorage.setItem(docKey, JSON.stringify(docDataLocal));
                                } catch (e) {
                                    console.warn('[Luna Composer] Could not update doc data:', e);
                                }
                            }
                        }
                    }
                }
            } catch (e) {
                console.warn('[Luna Composer] Could not fetch feedback from WordPress:', e);
            }
            
            // Fallback to localStorage if WordPress fetch failed
            if (!isLiked) {
                const feedbackKey = `luna_composer_feedback_${documentId}`;
                const feedbackStr = localStorage.getItem(feedbackKey);
                
                if (feedbackStr) {
                    try {
                        const feedbackData = JSON.parse(feedbackStr);
                        isLiked = feedbackData.feedback === 'like';
                    } catch (e) {
                        console.warn('[Luna Composer] Could not parse feedback:', e);
                    }
                }
                
                // Also check document data
                if (!isLiked) {
                    const docKey = `luna_composer_doc_${documentId}`;
                    const savedDoc = localStorage.getItem(docKey);
                    if (savedDoc) {
                        try {
                            const docData = JSON.parse(savedDoc);
                            isLiked = docData.feedback === 'like';
                        } catch (e) {
                            console.warn('[Luna Composer] Could not parse doc data:', e);
                        }
                    }
                }
            }
            
            // Update icon and button state
            if (isLiked) {
                heartIcon.setAttribute('src', 'https://visiblelight.ai/wp-content/uploads/2025/11/heart-solid-full.svg');
                heartBtn.style.background = '#000000';
                heartBtn.style.borderColor = '#1f1d1a';
            } else {
                // Default to dislike state
                heartIcon.setAttribute('src', 'https://visiblelight.ai/wp-content/uploads/2025/11/heart-regular-full-1.svg');
                heartBtn.style.background = '#2E2C2A50';
                heartBtn.style.borderColor = '#1f1d1a';
            }
        };
        
        // Show delete modal for history item
        window.lunaComposerShowDeleteModalForHistory = function(documentId, licenseKey) {
            console.log('[Luna Composer] Showing delete modal for history item:', documentId);
            
            // Store document ID and license key for deletion
            window.lunaComposerPendingDelete = {
                documentId: documentId,
                licenseKey: licenseKey
            };
            
            const modal = document.getElementById('luna-composer-delete-modal');
            if (modal) {
                modal.style.display = 'flex';
                // Reset delete button state
                const deleteBtn = document.getElementById('luna-composer-delete-confirm');
                if (deleteBtn) {
                    deleteBtn.disabled = true;
                    deleteBtn.style.opacity = '0.5';
                    deleteBtn.style.cursor = 'not-allowed';
                }
            } else {
                console.error('[Luna Composer] Delete modal not found');
            }
        };
        
        // Override download backup for history items
        const originalDownloadBackup = window.lunaComposerDownloadBackup;
        window.lunaComposerDownloadBackup = function() {
            // If we have a pending delete from history, load that document first
            if (window.lunaComposerPendingDelete) {
                const { documentId, licenseKey } = window.lunaComposerPendingDelete;
                
                // Try to load document content
                const docKey = `luna_composer_doc_${documentId}`;
                const savedDoc = localStorage.getItem(docKey);
                
                if (savedDoc) {
                    try {
                        const docData = JSON.parse(savedDoc);
                        if (docData.content) {
                            // Temporarily set editor content for backup
                            const editor = document.getElementById('luna-composer-editor');
                            if (editor) {
                                const originalContent = editor.innerHTML;
                                editor.innerHTML = docData.content;
                                
                                // Call original function
                                if (originalDownloadBackup) {
                                    originalDownloadBackup();
                                }
                                
                                // Restore original content after a delay
                                setTimeout(() => {
                                    editor.innerHTML = originalContent;
                                }, 1000);
                                
                                return;
                            }
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not parse doc data for backup:', e);
                    }
                }
            }
            
            // Otherwise, use original function
            if (originalDownloadBackup) {
                return originalDownloadBackup();
            }
        };
        
        // Override delete document function to handle history items
        const originalDeleteDocument = window.lunaComposerDeleteDocument;
        window.lunaComposerDeleteDocument = async function() {
            // Check if we're deleting from history
            if (window.lunaComposerPendingDelete) {
                const { documentId, licenseKey } = window.lunaComposerPendingDelete;
                
                try {
                    // Delete from WordPress
                    const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/delete', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({
                            license: licenseKey,
                            document_id: documentId
                        })
                    });
                    
                    if (response.ok) {
                        console.log('[Luna Composer] Document deleted from WordPress');
                    } else {
                        console.warn('[Luna Composer] Failed to delete from WordPress:', response.status);
                    }
                } catch (e) {
                    console.warn('[Luna Composer] Error deleting from WordPress:', e);
                }
                
                // Delete from localStorage
                const docKey = `luna_composer_doc_${documentId}`;
                localStorage.removeItem(docKey);
                
                // Remove feedback
                const feedbackKey = `luna_composer_feedback_${documentId}`;
                localStorage.removeItem(feedbackKey);
                
                // Remove from history
                const historyKey = `luna_composer_history_${licenseKey}`;
                const historyStr = localStorage.getItem(historyKey);
                if (historyStr) {
                    try {
                        const history = JSON.parse(historyStr);
                        const filteredHistory = history.filter(doc => doc.id !== documentId);
                        localStorage.setItem(historyKey, JSON.stringify(filteredHistory));
                    } catch (e) {
                        console.warn('[Luna Composer] Could not update history:', e);
                    }
                }
                
                // Close modal
                window.lunaComposerCloseDeleteModal();
                
                // Clear pending delete
                window.lunaComposerPendingDelete = null;
                
                // Reload history
                setTimeout(() => {
                    loadLunaComposerHistory();
                }, 300);
                
                return;
            }
            
            // Otherwise, use original function
            if (originalDeleteDocument) {
                return originalDeleteDocument();
            }
        };
        
        window.lunaComposerSubmitFeedback = async function(feedbackType) {
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            const content = editor.innerText || editor.textContent || '';
            const prompt = editor.getAttribute('data-prompt') || '';
            
            if (!documentId || !licenseKey) {
                console.error('[Luna Composer] Document ID or license key not found');
                return;
            }
            
            // Update button states
            const likeBtn = document.getElementById('luna-composer-like-btn');
            const dislikeBtn = document.getElementById('luna-composer-dislike-btn');
            
            if (feedbackType === 'like') {
                if (likeBtn) {
                    likeBtn.style.background = '#8D8C00';
                    likeBtn.style.borderColor = '#8D8C00';
                    likeBtn.disabled = true;
                }
                if (dislikeBtn) {
                    dislikeBtn.style.opacity = '0.5';
                    dislikeBtn.disabled = true;
                }
            } else {
                if (dislikeBtn) {
                    dislikeBtn.style.background = '#d63638';
                    dislikeBtn.style.borderColor = '#d63638';
                    dislikeBtn.disabled = true;
                }
                if (likeBtn) {
                    likeBtn.style.opacity = '0.5';
                    likeBtn.disabled = true;
                }
            }
            
            try {
                // Save feedback to WordPress
                const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/feedback', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        license: licenseKey,
                        document_id: documentId,
                        feedback_type: feedbackType,
                        prompt: prompt,
                        content: content.substring(0, 500) // First 500 chars for context
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('[Luna Composer] Feedback saved:', data);
                    
                    // Store feedback in localStorage for history categorization
                    const feedbackKey = `luna_composer_feedback_${documentId}`;
                    localStorage.setItem(feedbackKey, JSON.stringify({
                        feedback: feedbackType,
                        timestamp: Date.now()
                    }));
                    
                    // Also update document data if it exists
                    const docKey = `luna_composer_doc_${documentId}`;
                    const savedDoc = localStorage.getItem(docKey);
                    if (savedDoc) {
                        try {
                            const docData = JSON.parse(savedDoc);
                            docData.feedback = feedbackType;
                            localStorage.setItem(docKey, JSON.stringify(docData));
                        } catch (e) {
                            console.warn('[Luna Composer] Could not update doc data:', e);
                        }
                    }
                    
                    // Show confirmation
                    const feedbackButtons = document.getElementById('luna-composer-feedback-buttons');
                    if (feedbackButtons) {
                        const originalDisplay = feedbackButtons.style.display;
                        feedbackButtons.innerHTML = '<span style="color: #8D8C00; font-size: 0.875rem; padding: 4px 8px;">✓ Feedback saved</span>';
                        setTimeout(() => {
                            feedbackButtons.style.display = 'none';
                            // Restore buttons after a delay
                            setTimeout(() => {
                                feedbackButtons.innerHTML = '<button id="luna-composer-like-btn" onclick="window.lunaComposerSubmitFeedback(\'like\')" style="background: transparent; border: 1px solid #5A5753; color: #fff4e9; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease; display: flex; align-items: center; gap: 4px;" title="Like this response" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">👍 Like</button><button id="luna-composer-dislike-btn" onclick="window.lunaComposerSubmitFeedback(\'dislike\')" style="background: transparent; border: 1px solid #5A5753; color: #fff4e9; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease; display: flex; align-items: center; gap: 4px;" title="Dislike this response" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">👎 Dislike</button>';
                            }, 2000);
                        }, 1500);
                    }
                } else {
                    console.warn('[Luna Composer] Failed to save feedback:', response.status);
                    // Reset button states on error
                    if (likeBtn) {
                        likeBtn.style.background = 'transparent';
                        likeBtn.style.borderColor = '#5A5753';
                        likeBtn.disabled = false;
                        likeBtn.style.opacity = '1';
                    }
                    if (dislikeBtn) {
                        dislikeBtn.style.background = 'transparent';
                        dislikeBtn.style.borderColor = '#5A5753';
                        dislikeBtn.disabled = false;
                        dislikeBtn.style.opacity = '1';
                    }
                }
            } catch (e) {
                console.error('[Luna Composer] Error saving feedback:', e);
                // Reset button states on error
                if (likeBtn) {
                    likeBtn.style.background = 'transparent';
                    likeBtn.style.borderColor = '#5A5753';
                    likeBtn.disabled = false;
                    likeBtn.style.opacity = '1';
                }
                if (dislikeBtn) {
                    dislikeBtn.style.background = 'transparent';
                    dislikeBtn.style.borderColor = '#5A5753';
                    dislikeBtn.disabled = false;
                    dislikeBtn.style.opacity = '1';
                }
            }
        };
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            const shareMenu = document.getElementById('luna-composer-share-menu');
            const exportMenu = document.getElementById('luna-composer-export-menu');
            const shareBtn = document.getElementById('luna-composer-share-btn');
            const exportBtn = document.getElementById('luna-composer-export-btn');
            
            if (shareMenu && shareBtn && !shareMenu.contains(e.target) && !shareBtn.contains(e.target)) {
                shareMenu.style.display = 'none';
            }
            
            if (exportMenu && exportBtn && !exportMenu.contains(e.target) && !exportBtn.contains(e.target)) {
                exportMenu.style.display = 'none';
            }
        });
        
        } // Close the else block from authentication check
        
    </script>
</body>
</html>
